*** 入力文字変換の設定 ***
 
[ これは kinput2 で変換システムに Wnn を使用する時に使われる変換オブジェク  ]
[ ト CcWnn が使用しているローマ字かな変換 (だけではなく、変換に使用するキー ]
[ のバインディングやかな入力にも使用されるので「入力文字変換」と呼んでいま  ]
[ す) のカスタマイズ方法を解説したものです。実はこのドキュメントは wterm    ]
[ のユーザマニュアルの第4章『入力文字変換の設定』をちょっと変更しただけな   ]
[ のでもしかすると不適当な記述があるかも知れません。                        ]

    ここでは kinput2 の変換オブジェクトの一つ CcWnn が変換に使用するキーの
    バインディングやローマ字かな変換などをカスタマイズするのに必要な入力文
    字変換定義ファイルの書き方について説明します。ここに書かれた文章だけで
    はわかりにくいので、できればデフォルトの定義ファイル 
    (/usr/lib/X11/ccdef/ccdef.kinput2 およびその中でインクルードされている
    ファイル) を見ながら読むとよいと思います。また、最後にちょっとしたカス
    タマイズの例を紹介してあります。


** 入力文字変換の概要 
 
入力文字変換の機能には、大きく分けて次の二つがあります。
 
1. ローマ字かな変換など、入力された文字(列)を別の文字に置き換える
2. 入力されたキーにバインドされた変換機能を呼び出す
 
この二つの機能は分離されているのが普通ですが、CcWnn では分離されていません。
そのため、あるキーが入力された時にそれを別の文字に置き換えると同時にある変
換機能を呼び出す、ということができるようになっています。
 
ではここで入力文字変換がどのように行なわれるかについてざっと紹介しましょう。
 
基本的には、あらかじめ指定された変換ルールの集合の中から、
 
	・入力モード
	・入力コンテキスト
	・入力キー
 
の３つの条件にマッチする変換ルールを選び、それを適用することで変換が行なわ
れます。

・入力モード 
	これは例えば「ローマ字かな変換モード」とか、「アルファベット入力モー
	ド」とかいったものです。複数の入力モードを持つことができ、モードの
	切替えは変換ルールに書かれたファンクションで行ないます。

・入力コンテキスト 
	これはあるキーが押された時に、すでに入力されている文字列のことです。
	kinput2 で、アンダーラインつきで表示される未変換部分の文字列だと思
	えばだいたいよいでしょう。正確にいうと未変換部分のデータと入力コン
	テキストのデータは少し異なります。入力コンテキストの方は、入力モー
	ドが変わったりするとクリアされますし、最大16文字しか保持されません。

・入力キー 
	これは押されたキーです。変換ルールに
		・キーのアスキー表現 (XLookupString したもの)
		・キーのイベント表現 (モディファイア+Keysym)
	の２通りの形式で書くことができます。
 
実際の動作としては、まず初期化の段階で変換の定義ファイルが読み込まれます。
そこには、いくつかの入力モード (ローマ字かな変換モードとかアスキー文字入力
モードとか) ごとに変換ルールのセットが並んでいます。個々の変換ルールは次の
４つの項目から構成されます。
 
	・入力キー
	・コンテキスト文字列
	・変換結果文字列
	・ファンクション
 
入力キーとコンテキスト文字列が適用する変換ルールを選択するのに使用され、変
換結果文字列とファンクションが変換の内容を表します。
 
キーが入力されると、現在の入力モードに対応する変換ルールセットの中から、入
力されたキーおよび現在の入力コンテキストにマッチするルールが探されます。マッ
チするルールがあれば、その記述にしたがって文字の変換が行なわれ、変換ファン
クションが呼び出されます。
 
具体的な例で説明しましょう。変換定義ファイルに次のように書かれているとしま
す。
 
	mode Romaji "ローマ字入力"
		"k"	'a'	"か"
		"k"	'i'	"き"
		""	'a'	"あ"
		""	'i'	"い"
		""	'.'	"。"	convert
		... (省略) ...
	endmode
 
(定義ファイルの詳しい書き方についてはあとで説明します)
 
mode Romaji と書かれた行から endmode までがこのモード (Romaji) に対する変
換ルールです。一番最初のルールは、コンテキストが "k"、キーコードが 'a'、変
換文字列が"か" で、「"k" があらかじめ入力されている時に 'a' というキーが押
されたらそれを "か" という文字列に変換する」という意味です。
 
今 'a' というキーが押されたとしましょう。もし直前に k が入力されていれば一
番最初のルールにマッチして "か" という文字列に変換されて入力されます。もし 
k が入力されていなければ3番めのルールにマッチします。(空のコンテキストは何
にでもマッチします) そこでこの場合には "あ" という文字列に変換されます。
 
同様に '.' というキーが押されると4番めのルールにマッチして "。" という文字
列に変換されて入力されるとともに convert というファンクションが呼ばれます。
 
このように、入力文字変換の基本的なメカニズムは非常に簡単なのですが、実際に
はこれから説明していくようになかなか複雑です。


** 入力文字変換の動作 
 
それでは、入力文字変換機能がどのように動作するのかをもう少し詳しく説明しま
す。これを理解するには Xウィンドウに関する基本的な知識が必要でしょう。
 
まず、キーが押されるとそれに対応する KeyPress イベントがサーバから送られま
す。CcWnn はかな漢字変換機能が ON になっていればそれを入力文字変換のモジュー
ルに渡します。
 
現在の入力モードから、適用すべき変換ルールセットを選び、渡されたイベントと、
入力コンテキストをもとにマッチするルールを探します。
 
ルールの探索は一つのキーについて３回行なわれます。先ほど述べたように、変換
ルールにはキーをアスキー表現とイベント表現のどちらでも書けますし、イベント
表現で書く時に、例えば
 
	shift + Keysym 'a'
	Keysym 'A'
 
のどちらでも書けるようにするためです。
 
そこで、キーが押されるとキーの表現を変えて３回変換ルールが探されます。
 
1. モディファイアを一切解釈しないイベント表現
2. シフト・ロック・モードスイッチモディファイアを解釈したイベント表現
3. アスキー表現
 
この順に探され、最初にマッチしたルールにしたがって変換が行なわれます。
 
変換ルールは定義ファイルに書かれた順に探されます。従って定義ファイルに書く
順番を間違えると思った通りの変換が行なわれないことがあります。
 
マッチするルールがなかった場合、もし変換バッファが空 (確定されていない文字
がない) で、かつ押されたキーがコントロールコードだった場合にはそのまま出力
され、それ以外の場合は無視されます。
 
マッチするルールが見つかると、それにしたがって変換が行なわれます。
 
まず、変換バッファおよび入力コンテキストデータから変換ルールに書かれている
コンテキスト文字列が削除されます。(ルールがマッチしている以上、入力コンテ
キストおよび変換バッファの最後の部分はコンテキスト文字列と同じはずです)
 
次に変換バッファおよび入力コンテキストデータに、変換ルールに書かれている変
換結果文字列が追加されます。(実際には変換結果文字列中に入力コンテキストを
クリアする命令を入れておくこともできます。この場合には入力コンテキストデー
タは変換結果文字列の一部で置き換わることになります)
 
変換ルールにファンクションが書いてあれば、それが実行されます。ファンクショ
ンが複数書いてあれば前から順に実行されます。
 
ファンクションとして現在の入力モードを変える命令が書かれていた時には少し複
雑な処理を行ないます。まず入力モードを変える前に、 EXITMODE という仮想的な
キーで変換が行なわれます。そのあと入力モードを変更してから今度は
 ENTERMODE というキーで変換が行なわれます。この二つの仮想的なキーの入力に
より、モードが変わる時の特別な動作を定義ファイルに記述することができます。
最後に入力コンテキストがクリアされて、入力モードの変更にともなう処理が完了
します。
 
入力文字変換はこのようにして行なわれます。


** 変換定義ファイルの書き方 
 
変換は入力文字変換定義ファイルに書かれたルールにしたがって行なわれます。こ
こではその定義ファイルの書き方を説明します。
 
ファイルのフォーマットの説明に移る前に少し説明しておくことがあります。まず、
定義ファイルの中には漢字が書けるのですが、漢字コードは必ず EUC でなければ
なりません。それから、'#' で始まる行はコメントです。include 行で他のファイ
ルをインクルードすることができます。
 
	include 'ファイル名'
 
ファイル名が相対パス表記であれば、そのサーチパスは定義ファイルのものと同じ
で、
 
	1. カレントディレクトリ
	2. 環境変数  CC_DEF_PATH  に指定されたディレクトリ
	3.  /usr/lib/X11/ccdef/ 
 
の順になります。
 
では、定義ファイルのフォーマットの説明に移ります。定義ファイルは次のような
形式です。
 
	<モード宣言>
	<初期モード宣言>
	<各モードの変換ルール記述>
 
 
<モード宣言> には、使用する入力モード名をあらかじめ宣言しておきます。すべ
てのモードはここで宣言しておかななければなりません。これは必ず定義ファイル
の最初に書かれていなければなりません。次のような形式です。
 
	defmode <モード名1> <モード名2>...
	例) defmode Roma Ascii ZenkakuAscii
 
 
モード名に使えるのはアスキー文字だけです。漢字は使えません。
 
<モード宣言> の次には <初期モード宣言> が来ます。これは最初の入力モードを
指定するもので、次のような形式です。
 
	initialmode <モード名>
	例) initialmode Ascii
 
ここに指定するモードも、<モード宣言> で宣言しておく必要があります。
 
<初期モード宣言> のあとには、ここの入力モードに対する変換ルールの記述がき
ます。あるモードに対する記述形式は次のようになります。
 
	mode <モード名> <プロンプト文字列> [ fallthrough <モード名> ]
		<変換ルール1>
		<変換ルール2>
		...
	endmode
 
このように、各モードのルール記述は mode 行ではじまり、endmode 行で終ります。
 
<モード名> は <モード宣言> で宣言したモード名です。
 
<プロンプト文字列> はモードを表す、ダブルクォートで囲まれた文字列です。<プ
ロンプト文字列> には漢字も使用できます。これは現在の入力モードを表示するの
に使用されます。
 
[ fallthrough <モード名> ] と括弧で囲まれているのは、省略可能であることを
示します。もしこれが書いてある場合、変換の際このモードにマッチするルールが
なかった場合には引続きここに指定したモードのルールが探されます。
 
mode 行に続いて変換ルールの記述が並びます。変換ルールは定義ファイルに書か
れた順序通りにマッチングが調べられますので変換ルールを書く順番は重要です。


** 変換ルール 
 
この変換ルールは次のような形式で記述します。
 
<コンテキスト文字列> <キー> <変換結果文字列> [ <ファンクション>... ]
 
<コンテキスト文字列> はダブルクォートで囲まれた文字列です。あるルールが適
用されるためには、このコンテキスト文字列が現在の入力コンテキストとマッチす
る必要があります。マッチングは、このコンテキスト文字列が入力コンテキストの
最後の部分と一致するかどうかで判定されます。例えばあるルールのコンテキスト
文字列が"ky" だとすると、入力コンテキストの最後の２文字が "ky" であればマッ
チします。コンテキスト文字列が空文字列 ("") だった場合には、入力コンテキス
トが何であってもマッチします。
 
この文字列の中では '^' と ' ' の２つの文字が特殊キャラクタとして扱われます。'
^' はコントロールキーの表記に使います。"^C" と書けばこれはコントロール-C 
を表します。' ' は次の文字の、特殊キャラクタとしての意味をなくします。"
^C" はコントロール-C ではなく、'^' と 'C' の２文字からなる文字列を表します。
もちろん、' ' という文字自身を使いたいときには " " と重ねます。
 
<キー> は入力されたキーを表します。これは Xのキーイベント、キャラクタコー
ド、メタキャラクタ、疑似キーコードのいずれかを指定します。
 
Xのキーイベントは、
 
	[モディファイア-]Keysym名
 
のように表記します。モディファイアとしては
 
	shift
	lock
	control
	mod1
	mod2
	mod3
	mod4
	mod5
 
が使用できます。複数のモディファイアを指定する時にはハイフン ' ' でつなぎ
ます。Keysym名は X で定義されている Keysym の名前です。これは
/usr/include/X11/keysymdef.h で定義されている名前のから先頭の 'XK_' を取り
去ったものです。例えばタブキーは
 
	#define XK_Tab  0xFF09
 
と定義されていますから、Keysym名は 'Tab' になります。変換ルールに書ける X
のキーイベントの例としては次のようなものがあります。
 
	Tab
	shift-Tab
	control-mod1-space
 
次にキャラクタコードでの指定方法ですが、この時はシングルクォートで囲みます。
例えば次のように表記します。
 
	 'a'
	 '^['
	 ' ''
 
この表記にも特殊キャラクタ '^' と ' ' が使用できます。つまり上の例では２番
めの例はエスケープ (0x1e) を表し、３番めはシングルクォート文字を表していま
す。
 
メタキャラクタは次の 9 種類が用意されています。
 
	@any		何にでもマッチする
	@raw		キーイベントなら何にでもマッチ
	@func		ファンクションキーにマッチ
	@cursor		カーソルキーにマッチ
	@keypad		テンキーパッドのキーにマッチ
	@modifier	モディファイア (shift, control など) にマッチ
	@ascii		キャラクタコードなら何にでもマッチ
	@printable	印字可能文字 (0x20 ≦ c ≦ 0x7e) にマッチ
	@control	コントロール文字 (0x00 ≦ c ≦ 0x1f) にマッチ
 
これらのメタキャラクタで指定されたキーを <変換結果文字列> で参照するには
'&' を使用します。
 
疑似キーには次の２種類があります。
 

	ENTERMODE
	EXITMODE
 
これらは本当のキー入力ではありません。ENTERMODE はあるモードに入った時に仮
想的に入力されるキーであり、EXITMODE はあるモードから抜けた時に仮想的に入
力されるキーです。これらはあるモードにはいった時や抜けた時に特別の動作をさ
せるために用意されています。CcWnn ではこれらは JISコード入力のために使用さ
れています。
 
<変換結果文字列> はダブルクォートで囲まれた文字列で、その名の通りその変換
ルールが適用された時の変換結果を指定します。この変換結果は入力コンテキスト
にも入れられます。つまり、入力コンテキストのうち、<コンテキスト文字列> と
マッチした部分が<変換結果文字列> に変わります。例えば、入力コンテキストが
"...ばk" だった時に
 
	"k"	'a'	"か"
 
という変換ルールが適用されると入力コンテキストは "...ばか" に変わります。
 
<変換結果文字列> についてもいくつかの特殊キャラクタが定義されています。'^' 
と ' ' は <コンテキスト文字列> と同様の意味を持ちます。'&' は <キー> の表
すキャラクタと置き換えられます。これは <キー> にメタキャラクタを使用した場
合に便利です。例えば 'a' を押した時に
 
	""	@printable	"&"
 
というルールが適用されると、'&' は 'a' に置き換えられます。また、'/' は入
力コンテキストをクリアします。
 
	"k"	'a'	"か/"
 
というルールが適用されると "か" という文字列に変換されますが、入力コンテキ
ストはクリアされてなくなってしまいます。'/' を文字列の途中に入れることも可
能です。その場合には '/' のあとの部分だけが新しい入力コンテキストになりま
す。
 
<ファンクション> には、実行すべきファンクションを書きます。なければ書く必
要はありません。複数書かれた場合には、前から順に実行されます。
 
変換用ファンクションの他に特殊ファンクションとして、 goto と redo が用意さ
れています。
 
 goto  は現在の入力モードを変更するために使います。
 
	goto <モード名>
 
モード名として PREV を指定すると、その直前の入力モードに戻ることができます。
 
redo  は再変換をさせるために使います。
 
	redo
 
と書くともう一度マッチするルールを探しにいきます。ただし、その前に <コンテ
キスト文字列> が <変換結果文字列> で置き換えられているので、再び同じルール
がマッチするとは限りません。この機能を利用する時には、無限ループに陥らない
ように十分気をつける必要があります。一応 redo が 20回連続して呼ばれるとマッ
チングに失敗するようになってはいますが。
 
goto と redo のあとに書かれたファンクションは 実行されません 。ルールを書
く時には気をつけて下さい。
 
CcWnn で用意されている変換ファンクションとその機能の一覧を次に示します。機
能の記述の中で使われている [未変換] などはそれぞれ
 
	[未変換]	カレント文節が未変換である時の動作
	[変換済]	カレント文節がすでに変換されている時の動作
	[候補選択]	ステータスラインでの同音語選択モードでの動作
	[記号入力]	記号入力モードでの動作
 
を示しています。
 

ファンクション名	機能
------------------------------------------------------------------------------
convert		[未変換] カレント文節以降を連文節変換する
		[変換済] カレント大文節の候補選択モードにはいる
		[候補選択]  forward  と同じ
		[記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
convert-s	[未変換] カレント文節以降を連文節変換する
		[変換済] カレント小文節の候補選択モードにはいる
		[候補選択]  forward  と同じ
		[記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
unconvert	[変換済] カレント大文節を無変換の状態に戻す
		[未変換][候補選択][記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
next		[未変換] エラー (ベルが鳴る)
		[変換済] カレント大文節を次候補で置き換える
		[候補選択][記号入力] 次ページに移動する
------------------------------------------------------------------------------
next-s		[未変換] エラー (ベルが鳴る)
		[変換済] カレント小文節を次候補で置き換える
		[候補選択][記号入力] 次ページに移動する
------------------------------------------------------------------------------
previous	[未変換] エラー (ベルが鳴る)
		[変換済] カレント大文節を前候補で置き換える
		[候補選択][記号入力] 前ページに移動する
------------------------------------------------------------------------------
previous-s	[未変換] エラー (ベルが鳴る)
		[変換済] カレント小文節を前候補で置き換える
		[候補選択][記号入力] 前ページに移動する
------------------------------------------------------------------------------
forward		[未変換] カーソルを１文字進める
		[変換済] カレント文節を１小文節分後ろに移動する
		[候補選択][記号入力] 次候補(記号)に移動する
------------------------------------------------------------------------------
backward	[未変換] カーソルを１文字戻す
		[変換済] カレント文節を１小文節分前に移動する
		[候補選択][記号入力] 前候補(記号)に移動する
------------------------------------------------------------------------------
move-top	[未変換][変換済] カーソルおよびカレント文節を文の先頭に
		移動させる
		[候補選択][記号入力] 現在ページの先頭の候補(記号)に移動する
------------------------------------------------------------------------------
move-bottom	[未変換][変換済] カーソルおよびカレント文節を文の最後に
		移動させる
		[候補選択][記号入力] 現在ページの最後の候補(記号)に移動する
------------------------------------------------------------------------------
clear		[未変換][変換済] 入力した文を全て削除する
		[候補選択] 入力した文を全て削除し、候補選択モードから抜ける
		[記号入力] 入力した文を全て削除し、記号入力モードから抜ける
------------------------------------------------------------------------------
expand		[変換済] カレント大文節を一文字のばし再変換する
		[未変換][候補選択][記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
expand-s	[変換済] カレント小文節を一文字のばし再変換する
		[未変換][候補選択][記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
shrink		[変換済] カレント大文節を一文字ちぢめ再変換する
		[未変換][候補選択][記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
shrink-s	[変換済] カレント小文節を一文字ちぢめ再変換する
		[未変換][候補選択][記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
expand-noconv	[変換済] カレント大文節を一文字のばす 再変換はしない
		  (やってみるとわかりますがこれはあまり意味がありません)
		[未変換][候補選択][記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
expand-noconv-s	[変換済] カレント小文節を一文字のばす 再変換はしない
		  (やってみるとわかりますがこれはあまり意味がありません)
		[未変換][候補選択][記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
shrink-noconv	[変換済] カレント大文節を一文字ちぢめる 再変換はしない
		  (やってみるとわかりますがこれはあまり意味がありません)
		[未変換][候補選択][記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
shrink-noconv-s	[変換済] カレント小文節を一文字ちぢめる 再変換はしない
		  (やってみるとわかりますがこれはあまり意味がありません)
		[未変換][候補選択][記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
fix		[未変換][変換済] 文を確定する
		[候補選択] 現在カーソルがある候補を選択してから文を確定する
		[記号入力] 現在カーソルがある記号を選択してから文を確定する
------------------------------------------------------------------------------
fix2		[未変換][変換済][候補選択][記号入力] fix と同じ
		(fix は確定する文字がない時に実行するとベルを鳴らすが、
		fix2 は単に無視する)
------------------------------------------------------------------------------
to-hiragana	[未変換][変換済] カレント文節をひらがなにする
		[候補選択] カレント文節をひらがなにし、候補選択モードを抜ける
		[記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
to-katakana	[未変換][変換済] カレント文節をカタカナにする
		[候補選択] カレント文節をカタカナにし、候補選択モードを抜ける
		[記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
to-hankaku	[未変換][変換済] カレント文節を半角文字にする
		[候補選択] カレント文節を半角文字にし、候補選択モードを抜ける
		[記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
to-zenkaku	[未変換][変換済] カレント文節を全角文字にする
		[候補選択] カレント文節を全角文字にし、候補選択モードを抜ける
		[記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
backspace	[未変換] カーソルの前の文字を削除する
		[変換済] カレント大文節を未変換状態に戻してからカーソルの
		前の文字を削除する
		[候補選択] 候補選択モードを抜け、カレント文節を未変換状態に
		戻してからカーソルの前の文字を削除する
		[記号入力] 記号入力モードから抜ける
------------------------------------------------------------------------------
delete		[未変換] カーソルの下の文字を削除する
		[変換済] カレント大文節を未変換状態に戻してからカーソルの
		下の文字を削除する
		[候補選択] 候補選択モードを抜け、カレント大文節を未変換状態に
		戻してからカーソルの下の文字を削除する
		[記号入力] 記号入力モードから抜ける
------------------------------------------------------------------------------
carriage-return	[未変換][変換済] 文を確定し、その後改行文字を挿入する
		[候補選択][記号入力] 現在カーソルのある候補(記号)を選択する
------------------------------------------------------------------------------
jiscode-begin	[未変換][変換済] JISコード入力モードにはいる
		[候補選択][記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
jiscode-end	[未変換][変換済] JISコード入力モードをぬける
		[候補選択][記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
kutencode-begin	[未変換][変換済] 区点コード入力モードにはいる
		[候補選択][記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
kutencode-end	[未変換][変換済] 区点コード入力モードをぬける
		[候補選択][記号入力] エラー (ベルが鳴る)
------------------------------------------------------------------------------
symbol-input	[未変換][変換済] 記号入力モードにはいる
		[候補選択] エラー (ベルが鳴る)
		[記号入力] 記号入力モードから抜ける
------------------------------------------------------------------------------
beep		[未変換][変換済][候補選択][記号入力] ベルを鳴らす
------------------------------------------------------------------------------
convert-or-space[未変換][変換済] 未確定文字列があれば  convert  と同じ。
		なければスペースが挿入・確定される
		[候補選択][記号入力]  convert  と同じ
------------------------------------------------------------------------------
fix-or-cr	[未変換][変換済] 未確定文字列があれば確定する。
		なければ  carriage-return  と同じ
		[候補選択][記号入力]  carriage-return  と同じ
------------------------------------------------------------------------------

 
** カスタマイズ例 
 
ここでは入力文字変換定義ファイルのカスタマイズについて、具体例をあげて解説
します。

***   変換ファンクションのバインディング変更 
 
まずは変換に使用するキーの割当を変える例です。デフォルトのバインディングで
は変換は '^J' と '漢字' キーに割り当てられていますが、これを '^W' に変更し
てみます。
 
デフォルトの定義ファイル (/usr/lib/X11/ccdef/ccdef.kinput2) を見ると、
 
	include 'rule.func'
 
という行があり、変換に使用するキーはこのファイルに定義されていることがわか
ります。したがってこのファイルを変更すればよいのですが、
/usr/lib/X11/ccdef/rule.funcというファイルは他の人も参照しますから、これは
そのままにしておいた方がよいでしょう。
 
そこでまず環境変数 CC_DEF_PATH を定義して、定義ファイルのサーチパスを変更
します。.cshrc などで
 
	setenv CC_DEF_PATH ‾/ccdef
 
と設定すると、定義ファイルを探すのに ‾/ccdef というディレクトリが使われま
す。CC_DEF_PATH で指定したディレクトリはデフォルトのディレクトリである
/usr/lib/X11/ccdef よりも先に探されますので、ここに自分用の rule.func とい
うファイルを作ればいいわけです。/usr/lib/X11/ccdef/rule.func を 
‾/ccdef/rule.func にコピーしてからこれをエディットします。ファイル中に
 
	""	'^J'		""	convert
	""	Kanji		""	convert
 
という行がありますから、これを
 
	""	'^W'		""	convert
 
に置き換えれば終りです。

*** かな入力への変更 
 
次は、ローマ字かな変換をしてかなを入力するのではなく、直接かなを入力する人
のための変更です。
 
デフォルトの定義ファイルはローマ字入力用になっていて、ローマ字かな変換は 
Kana という入力モードで行なわれるようになっています。
 
	# ローマ字
	mode Kana	"ローマ"	fallthrough All
	    include 'rule.roma'
		""	Tab		""	goto Ascii
		""	shift-Tab	""	goto ZenkakuAscii
		"n"	EXITMODE	"ん"
	endmode
 
実際の変換ルールは rule.roma というファイルに入っています。
 
さて、ここを変えればかな入力用の定義ファイルができます。実はかな入力用の変
換ルールは /usr/lib/X11/ccdef/rule.kana に用意されています。このファイルに
は次のようなルールが書かれています。
 
	""	'3'	"あ"
	""	'#'	"ぁ"
	""	'e'	"い"
	""	'E'	"ぃ"
 
見ればわかると思いますが、このルールさえあれば別にかなキーボードでなくとも
かな入力することができます。
 
さて、この変更のためには ccdef.kinput2 を変更しなければなりません。そこで
先ほどと同じように環境変数 CC_DEF_PATH に ‾/ccdef を指定し、
/usr/lib/X11/ccdef/ccdef.kinput2 を ‾/ccdef/ccdef.kinput2 にコピーします。
そして、Kana モードの記述を
 
	# かな
	mode Roma	"かな"	fallthrough All
	    include 'rule.kana'
		""	Tab		""	goto Ascii
		""	shift-Tab	""	goto ZenkakuAscii
	endmode
 
 
に変えればかな入力用の定義ファイルの出来上がりです。

*** Emacs 用の変更 
 
カスタマイズの最後の例として、emacs を使う時に便利な変更を紹介します。

ご存知のように、emacs はコントロールキーを駆使して編集を行ないます。リソー
スsendBackKeyPress が True になっていれば、未確定の文字列がない状態ではほ
とんどのコントロールキーは(そのキーが変換ファンクションに割り当てられてい
ても) そのままアプリケーションに渡されますので、かな漢字変換ができる入力モー
ドのまま emacs にコマンドを与えることができます。しかし中には '^Xo' などの
ように２ストロークのコマンドがあり、これをローマ字入力モードのまま入力する
と '^X' は emacs に渡されますが、'o' は 'お' に変換されてしまいます。
 
これでは不便なので、'^X' と '^[' のあとの１文字はそのままアプリケーション
に渡されるように定義ファイルを修正してみます。

とはいってもこれはかなりトリッキーな方法を使う必要があります。

まず /usr/lib/X11/ccdef/ccdef.kinput2 を ‾/ccdef にコピーします。そして 新
たに AsciiHack、ZenkakuAsciiHack と KanaHack の３つのモードを追加します。

    defmode Ascii <中略> Restricted AsciiHack ZenkakuAsciiHack KanaHack

Ascii、ZenkakuAscii、Kana の各モードに次のルールを追加します。

	""	'^['	""	goto <モード名>Hack
	""	'^X'	""	goto <モード名>Hack

ただし <モード名> には各モード名が入ります。
次に AsciiHack、ZenkakuAsciiHack、KanaHack の各モードを追加します。

    mode <モード名> "<プロンプト文字列>"
	""	@ascii	""	goto PREV
    endmode

ここで重要なことは「<プロンプト文字列> には元のモード (AsciiHack なら 
Ascii)のプロンプト文字列と同じものを指定する」ということです。

このようにすると一応 '^X' と '^[' のあとの１文字はそのままアプリケーション
に渡されるようになります。ただあまりにもトリッキーな方法なので、なぜそうな
るのかは (ちょっと恥ずかしくて) ここでは説明しません。

