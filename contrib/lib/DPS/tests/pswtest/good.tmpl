/* goodfile.c generated from goodfile.psw
   by unix pswrap V1.009  Wed Apr 19 17:50:24 PDT 1989
 */

#include <DPS/dpsfriends.h>
extern int strlen();

#line 1 "goodfile.psw"
/*
 * goodfile.psw
 *
 * Copyright (C) 1988, 1989 by Adobe Systems Incorporated.
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notices appear in all copies and that
 * both those copyright notices and this permission notice appear in
 * supporting documentation and that the name of Adobe Systems
 * Incorporated not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior
 * permission.  If any portion of this software is changed, it cannot be
 * marketed under Adobe's trademarks and/or copyrights unless Adobe, in
 * its sole discretion, approves by a prior writing the quality of the
 * resulting implementation.
 * 
 * ADOBE MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THE SOFTWARE FOR
 * ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
 * ADOBE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO EVENT SHALL ADOBE BE LIABLE
 * TO YOU OR ANY OTHER PARTY FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE, STRICT LIABILITY OR ANY OTHER ACTION ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ADOBE WILL NOT
 * PROVIDE ANY TRAINING OR OTHER SUPPORT FOR THE SOFTWARE.
 * 
 * PostScript, Display PostScript, and Adobe are trademarks of Adobe Systems
 * Incorporated registered in the U.S.A. and other countries.
 *
 * Author: Adobe Systems Incorporated
 */

/*Purpose: Test pswrap: ability to pass all types of arguments
 *	to and from wrapped procedures, some pswrap scanner tests.
 *
 *Scope: 
 *	This suite mainly tests the parameter passing and type
 * 	conversion capabilities of code generated by pswrap; it
 *	tests pswrap in an indirect manner by 'testing' this
 *	generated code. There are other tests which judge pswrap's
 *	ability to detect various error conditions and correctly
 *	report them. Some errors detected at runtime (type mismatches)
 *	are forced.
 *
 *Functionality: 
 *	See individual test descriptions.
 *
 *StandAlone: true
 *
 *Usage:
 *	goodfile [-a -t]
 *	-a	Create a chained FILE context to log all output
 *		to the server to stdout or a file.
 *	-t	Trace: write the name of each wrap to stdout just
 *		before it is executed.
 */

#include <stdio.h>

#include <DPS/dpsclient.h>
#include <DPS/dpsXclient.h>
#include <DPS/dpsexcept.h>

#define LINEBUF 256

#define stdin_fd 0
#define stdout_fd 1

#define VOID (void)

/* exit errors (MPW conventions) */
#define NO_ERROR 0
#define CMDLINE_ERROR 1
#define PROG_ERROR 2	/* PS error */
#define SYS_ERROR 3

#define DoWrap(wrap,args) \
    wrapName = "wrap"; \
    if (optionTrace) TraceWrapName(); \
    wrap args, \
    DPSWaitContext(context)

typedef	long int Userobject;

/* Global Vars */

Bool		optionTrace,	/* write wrap names to stdout */
		doAscii,
		doStrings;
char 		*prog;		/* program name */
char 		*wrapName;	/* current wrap name */
char		*testName;	/* current test name */
char		*chainedFile;	/* name of file for chained File context */
DPSContext      context;        /* Context holder. */
DPSContext      fdcontext;      /* Chained Context holder. */
int		errCount;	/* number of tests ending in error */
unsigned long	saveExceptionArg1,
		saveExceptionArg2;
FILE		*textFd = stderr; /* FD to write returned text to */
Display		*dpy;		/* X display structure */

/* Utility procedures */

static void CleanUpAndExit(exitCode)
  int exitCode;
  {
  if (context)
    DPSDestroySpace(DPSSpaceFromContext(context));
  exit (exitCode);
  }

/* Command line parser - sets state of global variables as
   appropriate */

void GetCommandLineOptions(pArgc, pArgv)
  int	*pArgc;
  char	**pArgv[];
  {
  int	argc = *pArgc;
  char	**argv;
  char	*argP;

  argv = *pArgv;
  prog = *argv;
  ++argv;
  --argc;
    
  while (argc > 0 && **argv == '-') {
    argP = *argv;
    switch (argP[1]) {
      case 't':	/* trace wrap execution */
        optionTrace = True; break;
      case 'a': 
        doAscii = True; 
	if ((argc > 1) && (**(argv+1) != '-')) {
          argv++; argc--;
          if ((textFd = fopen(*argv, "w")) == NULL) {
            VOID fprintf(stderr, "pswtest: can't open file (%s)\n", *argv);
            CleanUpAndExit(CMDLINE_ERROR);
            }
	  }
	break;
      default:
        fprintf(stderr, "Unknown option %s\n", argP);
        CleanUpAndExit(CMDLINE_ERROR);
      }
    argv++;
    argc--;
    }

  *pArgc = argc;
  *pArgv = argv;
  }


static void Error(msg)
  char *	msg;	/* error message */
  {
  fprintf(stderr, "Error in %s wrap: %s\n", wrapName, msg);
  }

static void CmpError(exp, actual)
  char *	exp;	/* expected value */
  char *	actual;	/* actual value */
  {
  Error(testName);
  fprintf(stderr, "  Expected result:\n    %s\n  Got:\n    %s\n",
    exp, actual);
  }


#define Compare(exp, actual, format)\
  if (exp != actual) {\
    char expStr[32], actualStr[32];\
    (void) sprintf(expStr, format, exp);\
    (void) sprintf(actualStr, format, actual);\
    CmpError(expStr, actualStr);\
    }

#define CompareReal(exp, actual)\
  if (exp != actual) {\
    char expStr[32], actualStr[32];\
    (void) sprintf(expStr, "%g", exp);\
    (void) sprintf(actualStr, "%g", actual);\
    CmpError(expStr, actualStr);\
    }

static void CompareDouble(exp, actual)
  double	exp, actual;
  {
#define ERROR 0.001
  double d;
  d = exp - actual;
  d = d < 0.0 ? -d : d;
  if ((d < -ERROR) || (d > ERROR)) {
    char expStr[32], actualStr[32];
    (void) sprintf(expStr, "%g", exp);
    (void) sprintf(actualStr, "%g", actual);
    CmpError(expStr, actualStr);
    }
  }
      
static void TraceWrapName()
  {
  printf("Executing %s ...\n", wrapName);
  fflush(stdout);
  }

static void AppTextProc(ctxt, buf, count)
  DPSContext ctxt;
  char *buf;
  unsigned int count;
{
    (void) fflush(stdout);
    (void) fwrite(buf, sizeof(char), count, textFd);
    (void) fflush(textFd);
}

static void AppErrorProc(ctxt, errorCode, arg1, arg2)
  DPSContext ctxt;
  DPSErrorCode errorCode;
  long unsigned int arg1, arg2;
  {
  saveExceptionArg1 = arg1;
  saveExceptionArg2 = arg2;
  if (errorCode != dps_err_ps)
    /* Allow any established error handler to see this rather
       than letting the DPSDefault handler have it - the default
       handler won't RAISE non-ps errors */
    RAISE(errorCode, (char *) ctxt);
  else {
    /* Pass this on to the default handler - it will print its
       message and RAISE the error so our outermost handler
       has a chance to Reset the context */
    Error("");
    DPSDefaultErrorProc(ctxt, errorCode, arg1, arg2);
    }
  }

DPSContext CreateContext()
  {
  DPSContext context;

  context = XDPSCreateSimpleContext(dpy, None, None, 0, 0,
    AppTextProc, AppErrorProc, NULL);

  if (context == NULL) {
    fprintf(stderr, "Unable to create context\n");
    CleanUpAndExit(SYS_ERROR);
    }
  return(context);
  }

/* Wrap called after forcing a deliberate error - cleans up
   the operand and dict stacks. */
#line 268 "goodfile.c"
void PSWCleanup()
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 2, 20,
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 18},	/* clear */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 375},	/* cleardictstack */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,20);
}
#line 262 "goodfile.psw"


/*==================================================================
 TEST: Booleans
 DESCRIPTION:
   Tests the ability to pass both boolean values to a wrap and
   have the same values returned, and to receive expected boolean
   results from a wrap that evaluates a specified boolean expression.
 TESTS:
   BASIC OPERATION:
	Case 1: --- End-to-end tests ---
		True and false boolean values are passed to a wrap
		which echos those values as results.
	Case 2: --- Return result of boolean expression ---
		A wrap which tests the equality of two integer
		arguments and returns the result is called with
		pairs of integers that will result in true and
		false values being returned.
	Case 3:	--- Return value is overwritten ---
		A 'true' value is passed to a wrap which first
		returns 'false' then 'true'. The 'true' value is 
		verified as the correct return value.
 NOT TESTED:
	None.
 END TEST DESCRIPTION
===================================================================*/

#define CompareBoolean(exp, actual)\
  if (exp != actual) {\
    char *expStr, *actualStr;\
    expStr = exp ? "true" : "false";\
    actualStr = actual ? "true" : "false";\
    CmpError(expStr, actualStr);\
    }
#line 322 "goodfile.c"
void PSWBooleanRoundTrip(in, result)
int in; int *result; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_BOOL, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tBoolean, -1 },
    };
    _dpsR[0].value = (char *)result;


  _dpsP[0].val.booleanVal = (long) (0 != in);
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 299 "goodfile.psw"

#line 364 "goodfile.c"
void PSWBooleanExpression(a, b, result)
int a, b; int *result; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    DPSBinObjGeneric obj8;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 9, 76,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: a */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: b */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 61},	/* eq */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tBoolean, -1 },
    };
    _dpsR[0].value = (char *)result;


  _dpsP[0].val.integerVal = a;
  _dpsP[1].val.integerVal = b;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,76);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 303 "goodfile.psw"

#line 411 "goodfile.c"
void PSWBooleanOverwrite(in, result)
int in; int *result; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    DPSBinObjGeneric obj8;
    DPSBinObjGeneric obj9;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 10, 84,
    {DPS_LITERAL|DPS_BOOL, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_BOOL, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tBoolean, -1 },
    };
    _dpsR[0].value = (char *)result;


  _dpsP[0].val.booleanVal = (long) (0 != in);
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,84);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 307 "goodfile.psw"


void Booleans()
  {
  int /* boolean */	in, out;

  /* Case 1 */

  DoWrap(PSWBooleanRoundTrip, (True, &out));
  CompareBoolean(True, out);
  DoWrap(PSWBooleanRoundTrip, (False, &out));
  CompareBoolean(False, out);

  /* Case 2 */

  DoWrap(PSWBooleanExpression, (1, 1, &out));
  CompareBoolean(True, out);
  DoWrap(PSWBooleanExpression, (1, 2, &out));
  CompareBoolean(False, out);

  /* Case 3 */

  DoWrap(PSWBooleanOverwrite, (True, &out));
  CompareBoolean(True, out);

  }


/*==================================================================
 TEST: User objects
 DESCRIPTION:
   Tests ability to pass user object IDs and have them correctly
   evaluated. No 'return value' tests are performed: userobject
   is not a valid type for returned values.
 TESTS:
   BASIC OPERATION:
	Case 1: --- Test correct evaluation of userobject ID ---
		A wrap that associates a given ID with the
		integer value '10' is called. The ID is then passed
		to a wrap which evaluates the ID and should return
		the integer value '10'.
	Case 2: --- Test correct evaluation of userobject ID ---
		A wrap that associates a given ID with an executable
		array (procedure) is called. The ID is then passed
		to a wrap which evaluates the ID and should execute
		the procedure. The procedure negates the top element
		on the stack (which is a copy of an integer value
		passed to the wrap). The top value is then returned
		as the wrap result. We expect this result to be 
		the negative of the wrap's input value.
 NOT TESTED:
	None.
 END TEST DESCRIPTION
===================================================================*/
#line 512 "goodfile.c"
void PSWUserobjectDefineInt(id)
long int id; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 3, 28,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: id */
    {DPS_LITERAL|DPS_INT, 0, 0, 10},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 372},	/* defineuserobject */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;

  _dpsP[0].val.integerVal = id;
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,28);
}
#line 364 "goodfile.psw"

#line 539 "goodfile.c"
void PSWUserobjectEvalInt(id, result)
int id; int *result; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 8, 68,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: id */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 212},	/* execuserobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tInt, -1 },
    };
    _dpsR[0].value = (char *)result;


  _dpsP[0].val.integerVal = id;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,68);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 368 "goodfile.psw"

#line 583 "goodfile.c"
void PSWUserobjectDefineProc(id)
long int id; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 3, 36,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: id */
    {DPS_EXEC|DPS_ARRAY, 0, 1, 24},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 372},	/* defineuserobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 110},	/* neg */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;

  _dpsP[0].val.integerVal = id;
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,36);
}
#line 372 "goodfile.psw"

#line 612 "goodfile.c"
void PSWUserobjectEvalProc(id, val, result)
int id; int val; int *result; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    DPSBinObjGeneric obj8;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 9, 76,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: val */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: id */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 212},	/* execuserobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tInt, -1 },
    };
    _dpsR[0].value = (char *)result;


  _dpsP[1].val.integerVal = id;
  _dpsP[0].val.integerVal = val;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,76);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 376 "goodfile.psw"


void UserObjects()
  {
  Userobject	objID;
  int		result;

  /* Case 1 */

  objID = 1;
  DoWrap(PSWUserobjectDefineInt, (objID));
  DoWrap(PSWUserobjectEvalInt, (objID, &result));
  Compare(10, result, "%d");

  /* Case 2 */

  objID = 2;
  DoWrap(PSWUserobjectDefineProc, (objID));
  DoWrap(PSWUserobjectEvalProc, (objID, 25, &result));
  Compare(-25, result, "%d");

  }

/*==================================================================
 TEST: Integers
 DESCRIPTION:
   Tests verify the proper output and input of all integer types,
   both signed and unsigned. Truncation of long values when
   returned to variables of shorter types is checked. Returning
   integer values into float and double variables is also checked.
 TESTS:
   BASIC OPERATION:
	Case 1: --- Basic round-trip tests ---
		Signed short, int, and long values are
		passed to a wrap and returned to variables of
		the same type. The values of passed and returned
		variables are checked for equality. This test is
		performed for values at each end of the range
		for each type.
	Case 2: --- Use unsigned types ---
		Unsigned short, int, and long values are
		passed and returned as the corresponding signed
		types. This tests whether the wrap body is properly
		casting unsigned input arguments to signed integers.
	Case 3: --- Return truncated value ---
		The wrap returns a value that exceeds the max
		value for a short int. Correct truncation
		of the returned value is verified; the short 
		variable is declared in the middle of an
		array of elements with known values. Array elements
		'on either side' of the returned value are checked
		to verify their contents have not been smashed.
	Case 4:	--- Pass integer, return float, double ---
		Max and min long int values are passed to a wrap
		that returns a float value to verify correct
		conversion of integer to real on returned values.
		The same test is repeated with a wrap that returns
		double values instead of floats.
	Case 5:	--- Return value is overwritten ---
		A known value is passed to a wrap which first
		returns the negative of the input parameter,
		then returns the original value of the input
		parameter. The original value is verified as
		the correct return value.
 NOT TESTED:
	None.
 END TEST DESCRIPTION
===================================================================*/
#line 726 "goodfile.c"
void PSWShortIntRoundTrip(in, out)
short int in; short int *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tShort, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.integerVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 447 "goodfile.psw"

#line 768 "goodfile.c"
void PSWIntRoundTrip(in, out)
int in; int *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tInt, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.integerVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 451 "goodfile.psw"

#line 810 "goodfile.c"
void PSWLongIntRoundTrip(in, out)
long int in; long int *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tLong, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.integerVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 455 "goodfile.psw"

#line 852 "goodfile.c"
void PSWUshortIntRoundTrip(in, out)
unsigned short int in; short int *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tShort, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.integerVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 459 "goodfile.psw"

#line 894 "goodfile.c"
void PSWUintRoundTrip(in, out)
unsigned int in; int *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tInt, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.integerVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 463 "goodfile.psw"

#line 936 "goodfile.c"
void PSWUlongIntRoundTrip(in, out)
unsigned long int in; long int *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tLong, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.integerVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 467 "goodfile.psw"

#line 978 "goodfile.c"
void PSWTruncateToShort(in, out)
int in; short int *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tShort, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.integerVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 471 "goodfile.psw"

#line 1020 "goodfile.c"
void PSWLongToFloat(in, out)
long int in; float *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tFloat, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.integerVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 475 "goodfile.psw"

#line 1062 "goodfile.c"
void PSWLongToDouble(in, out)
long int in; double *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tDouble, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.integerVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 479 "goodfile.psw"

#line 1104 "goodfile.c"
void PSWIntOverwrite(in, out)
int in; int *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    DPSBinObjGeneric obj8;
    DPSBinObjGeneric obj9;
    DPSBinObjGeneric obj10;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 11, 92,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: in */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 56},	/* dup */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 110},	/* neg */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tInt, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.integerVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,92);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 483 "goodfile.psw"


long GenMax(typeSize)
  int	typeSize;
  {
  int	bits = typeSize * 8 - 1;
  long	val = 0;

  for (; bits > 0; bits--)
    val = (val << 1) + 1;
  return(val);
  }

void Integers()
  {
  short s, sR; int i, iR; long l, lR; 
  short a[3];
  unsigned short us, maxUshort; unsigned int ui, maxUint; 
  unsigned long ul, maxUlong;
  long maxShort, minShort, maxInt, minInt, maxLong, minLong;
  float f; double d;

  maxShort = GenMax(sizeof(short)); minShort = -maxShort - 1;
  maxUshort = ((unsigned short) maxShort << 1) + 1;
  maxInt = GenMax(sizeof(int)); minInt = -maxInt - 1;
  maxUint = ((unsigned int) maxInt << 1) + 1;
  maxLong = GenMax(sizeof(long)); minLong = -maxLong - 1;
  maxUlong = ((unsigned long) maxLong << 1) + 1;

  /* Case 1 */

  s = minShort;
  DoWrap(PSWShortIntRoundTrip, (s, &sR));
  Compare(s, sR, "%d");
  s = maxShort;
  DoWrap(PSWShortIntRoundTrip, (s, &sR));
  Compare(s, sR, "%d");

  i = minInt;
  DoWrap(PSWIntRoundTrip, (i, &iR));
  Compare(i, iR, "%d");
  i = maxInt;
  DoWrap(PSWIntRoundTrip, (i, &iR));
  Compare(i, iR, "%d");

  l = minLong;
  DoWrap(PSWLongIntRoundTrip, (l, &lR));
  Compare(l, lR, "%ld");
  l = maxLong;
  DoWrap(PSWLongIntRoundTrip, (l, &lR));
  Compare(l, lR, "%ld");

  /* Case 2 */

  us = maxUshort;
  DoWrap(PSWUshortIntRoundTrip, (us, &sR));
  Compare((short) us, sR, "%d");

  ui = maxUint;
  DoWrap(PSWUintRoundTrip, (ui, &iR));
  Compare((int) ui, iR, "%d");

  ul = maxUlong;
  DoWrap(PSWUlongIntRoundTrip, (ul, &lR));
  Compare((long) ul, lR, "%ld");

  /* Case 3 */

  a[0] = -1; a[1] = -2; a[2] = -3;
  DoWrap(PSWTruncateToShort, (maxUshort + 2, &a[1]));
  Compare(1, a[1], "%d");
  Compare(-1, a[0], "%d");
  Compare(-3, a[2], "%d");

  /* Case 4 */

  DoWrap(PSWLongToFloat, (maxLong, &f));
  CompareReal((float) maxLong, f);
  DoWrap(PSWLongToFloat, (minLong, &f));
  CompareReal((float) minLong, f);

  DoWrap(PSWLongToDouble, (maxLong, &d));
  CompareDouble((double) maxLong, d);
  DoWrap(PSWLongToDouble, (minLong, &d));
  CompareDouble((double) minLong, d);

  /* Case 5 */

  DoWrap(PSWIntOverwrite, (maxInt, &i));
  Compare(maxInt, i, "%d");

  }


/*==================================================================
 TEST: Real number output & input
 DESCRIPTION:
   Variables of type float and double are passed to wraps which
   return the same values to test the conversion of C 'real' types
   to PS reals and back again. Typecheck errors are tested by
   trying to return a real number when the result is defined
   as int. The results of passing double values that exceed the 
   PS max real number range tested.
 TESTS:
   BASIC OPERATION:
	Case 1: --- Basic round-trip tests ---
		Max and min float values are passed to a wrap
		that echos the same values back. Double values
		in the range of max/min float values are passed
		to a wrap that echos the same values back.
		The same tests are repeated for float values
		closest to 0 (both positive and negative).
	Case 2: --- Fractional float -> integer tests ---
		Positive and negative float values with fractional
		parts are passed to a wrap which returns integer
		values. This should generate a typecheck error.
	Case 3:	--- Large double value truncation tests ---
		Double values exceeding -1E38 and 1E38 are passed
		to a wrap which returns float values. The returned
		results should equal "Infinity".
	Case 4:	--- Return value is overwritten ---
		A known value is passed to a wrap which first
		returns the negative of the input parameter,
		then returns the original value of the input
		parameter. The original value is verified as
		the correct return value.
 NOT TESTED:
	None.
 END TEST DESCRIPTION
===================================================================*/
#line 1283 "goodfile.c"
void PSWFloatRoundTrip(in, out)
float in; float *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjReal obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_REAL, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tFloat, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.realVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 616 "goodfile.psw"

#line 1325 "goodfile.c"
void PSWDoubleRoundTrip(in, out)
double in; double *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjReal obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_REAL, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tDouble, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.realVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 620 "goodfile.psw"

#line 1367 "goodfile.c"
void PSWFloatToInt(in, out)
float in; int *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjReal obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_REAL, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tInt, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.realVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 624 "goodfile.psw"

#line 1409 "goodfile.c"
void PSWDoubleToFloat(in, out)
double in; float *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjReal obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_REAL, 0, 0, 0},	/* param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tFloat, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.realVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 628 "goodfile.psw"

#line 1451 "goodfile.c"
void PSWFloatOverwrite(in, out)
float in; float *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjReal obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    DPSBinObjGeneric obj8;
    DPSBinObjGeneric obj9;
    DPSBinObjGeneric obj10;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 11, 92,
    {DPS_LITERAL|DPS_REAL, 0, 0, 0},	/* param: in */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 56},	/* dup */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 110},	/* neg */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tFloat, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.realVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,92);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 632 "goodfile.psw"

#line 1501 "goodfile.c"
void PSWDoubleOverwrite(in, out)
double in; double *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjReal obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    DPSBinObjGeneric obj8;
    DPSBinObjGeneric obj9;
    DPSBinObjGeneric obj10;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 11, 92,
    {DPS_LITERAL|DPS_REAL, 0, 0, 0},	/* param: in */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 56},	/* dup */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 110},	/* neg */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tDouble, -1 },
    };
    _dpsR[0].value = (char *)out;


  _dpsP[0].val.realVal = in;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,92);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 636 "goodfile.psw"


void Reals()
  {
  float f, fR, maxFloat, minFloat, smallestFraction, smallestNegFraction;
  double d, dR, largeDouble, smallDouble;
  Bool gotException;
  int	i;

  maxFloat = 1E38; minFloat = -1E38;
  smallestFraction = 1e-38; smallestNegFraction = -1E-38;
  largeDouble = maxFloat * 10; smallDouble = minFloat * 10;

  /* Case 1 */

  f = minFloat;
  DoWrap(PSWFloatRoundTrip, (f, &fR));
  CompareReal(f, fR);
  f = maxFloat;
  DoWrap(PSWFloatRoundTrip, (f, &fR));
  CompareReal(f, fR);

  d = minFloat;
  DoWrap(PSWDoubleRoundTrip, (d, &dR));
  CompareDouble(d, dR);
  d = maxFloat;
  DoWrap(PSWDoubleRoundTrip, (d, &dR));
  CompareDouble(d, dR);

  f = smallestFraction;
  DoWrap(PSWFloatRoundTrip, (f, &fR));
  CompareReal(f, fR);
  f = smallestNegFraction;
  DoWrap(PSWFloatRoundTrip, (f, &fR));
  CompareReal(f, fR);

  d = smallestFraction;
  DoWrap(PSWDoubleRoundTrip, (d, &dR));
  CompareDouble(d, dR);
  d = smallestNegFraction;
  DoWrap(PSWDoubleRoundTrip, (d, &dR));
  CompareDouble(d, dR);

  /* Case 2 */

  gotException = False;
  DURING
    DoWrap(PSWFloatToInt, (maxFloat, &i));
  HANDLER
    if (Exception.Code != dps_err_resultTypeCheck)
      RERAISE;
    gotException = True;
  END_HANDLER

  if (!gotException)
    Error("expected typecheck error - none occurred");

  /* Case 3 */

  DoWrap(PSWDoubleToFloat, (largeDouble, &f));
  Compare((float) largeDouble, f, "%g");

  DoWrap(PSWDoubleToFloat, (smallDouble, &f));
  Compare((float) smallDouble, f, "%g");

  /* Case 4 */

  DoWrap(PSWFloatOverwrite, (maxFloat, &f));
  CompareReal(maxFloat, f);

  DoWrap(PSWDoubleOverwrite, (maxFloat, &d));
  CompareDouble(maxFloat, d);

  }


/*==================================================================
 TEST: Character strings
 DESCRIPTION:
   Tests correct operation of wraps accepting character strings
   and arrays as input parameters and returning character strings
   and arrays as output parameters. Types of tests include: basic 
   'echo' testing (treating the input parameters as PS string
   objects), treating char strings as PS names (both literal and
   executable), returning a series of array elements, and arrays
   declared with both static and dynamic bounds.
 TESTS:
   BASIC OPERATION:
	Case 1: --- Basic round-trip tests ---
		Character strings (up to the maximum PS string
		limit) are passed to a wrap which (treating the
		parameter as a string object) returns the string
		as its result. The same test is performed using
		character arrays of statically and dynamically
		declared length.
	Case 2: --- String as name tests ---
		A string is is passed to a wrap which "defs" the 
		string as the name of an integer object with value as 
		specified as a parameter to the wrap. This name is
		then looked up as a literal name via "known";
		if found, the name is executed. This produces its
		value which is then returned as the wrap result.
		If not found, the original input value is negated
		and returned.
		Also, try passing a string longer than the max
		name to the same wrap. A "dps_err_nameTooLong"
		error should result.
	Case 3:	--- Returning character strings ---
		A wrap that returns a string of the specified
		length is called twice:
		- a 255 byte string is returned. Each byte has
		  a value equal to its index in the string. The
		  string is checked for a null terminator in the
		  proper position.
		- a 0 length string is returned.
		A wrap that returns a series of strings to a single
		return parameter is called to test that only the 
		first string in the series is returned.
	Case 4:	--- Returning character arrays ---
		A wrap that accepts a character array with dynamic
		bounds and a "return chunk" size as input parameters,
		and returns an array with dynamically specified bounds
		is called with different sets of parameters:
		- the input string, return chunk size, and output
		  array bounds make the wrap return an array the
		  same size as the input array - the data is
		  stored in the array in one reference.
		- the input string, return chunk size, and output
		  array bounds make the wrap return an array shorter
		  than the input array. The wrap attempts to store
		  results in the output array in two chunks; the
		  first chunk fits, and all but the last byte of
		  the second chunk fits.
		- the input string, return chunk size, and output
		  array bounds make the wrap return an array shorter
		  than the input array. The wrap attempts to store
		  results in the output array in two chunks; the
		  first chunk fits but only the first byte of the
		  second chunk fits.
		- the input string, return chunk size, and output
		  array bounds make the wrap return an array longer
		  than the input array. The result data is stored
		  in 3 chunks; the returned string is checked to
		  ensure that bytes beyond those explicitly returned
		  by the wrap have not been overwritten.
 NOT TESTED:
	Passing string longer than size allowed by PS.
 END TEST DESCRIPTION
===================================================================*/
#line 1699 "goodfile.c"
void PSWCharStringRoundTrip(in, out)
char *in; char *out; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char sizeFlag;
    unsigned short topLevelCount;
    unsigned long nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 0, 7, 64,
    {DPS_LITERAL|DPS_STRING, 0, 0, 56},	/* param in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  register int _dps_offset = 56;
  static DPSResultsRec _dpsR[] = {
    { dps_tChar, -1 },
    };
    _dpsR[0].count = -1;
    _dpsR[0].value = (char *)out;


  _dpsP[0].length = strlen(in);
  _dpsP[0].val.stringVal = _dps_offset;
  _dps_offset += _dpsP[0].length;

  _dpsF.nBytes = _dps_offset+8;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,64);
  DPSWriteStringChars(_dpsCurCtxt, (char *)in, _dpsP[0].length);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 788 "goodfile.psw"

#line 1749 "goodfile.c"
void PSWCharStaticArrayRoundTrip(in, out)
char in[]; char out[]; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 70,
    {DPS_LITERAL|DPS_STRING, 0, 10, 56},	/* param[const]: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  static DPSResultsRec _dpsR[] = {
    { dps_tChar },
    };
    _dpsR[0].count = 10;
    _dpsR[0].value = (char *)out;

  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSWriteStringChars(_dpsCurCtxt, (char *)in, 10);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 792 "goodfile.psw"

#line 1790 "goodfile.c"
void PSWCharVarArrayRoundTrip(in, l, out)
char in[]; int l; char out[]; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_STRING, 0, 0, 56},	/* param in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  register int _dps_offset = 56;
  static DPSResultsRec _dpsR[] = {
    { dps_tChar },
    };
    _dpsR[0].count = l;
    _dpsR[0].value = (char *)out;


  _dpsP[0].length = l;
  _dpsP[0].val.stringVal = _dps_offset;
  _dps_offset += l;

  _dpsF.nBytes = _dps_offset+4;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSWriteStringChars(_dpsCurCtxt, (char *)in, l);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 796 "goodfile.psw"

#line 1839 "goodfile.c"
void PSWCharStrAsName(name, value, result)
char *name; int value; int *result; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char sizeFlag;
    unsigned short topLevelCount;
    unsigned long nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    DPSBinObjGeneric obj8;
    DPSBinObjGeneric obj9;
    DPSBinObjGeneric obj10;
    DPSBinObjGeneric obj11;
    DPSBinObjGeneric obj12;
    DPSBinObjGeneric obj13;
    DPSBinObjGeneric obj14;
    DPSBinObjGeneric obj15;
    DPSBinObjGeneric obj16;
    DPSBinObjGeneric obj17;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 0, 15, 152,
    {DPS_LITERAL|DPS_NAME, 0, 0, 144},	/* param name */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: value */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 51},	/* def */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 182},	/* userdict */
    {DPS_LITERAL|DPS_NAME, 0, 0, 144},	/* param name */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 96},	/* known */
    {DPS_EXEC|DPS_ARRAY, 0, 1, 136},
    {DPS_EXEC|DPS_ARRAY, 0, 2, 120},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 85},	/* ifelse */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: value */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 110},	/* neg */
    {DPS_EXEC|DPS_NAME, 0, 0, 144},	/* param name */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  register int _dps_offset = 144;
  static DPSResultsRec _dpsR[] = {
    { dps_tInt, -1 },
    };
    _dpsR[0].value = (char *)result;


  _dpsP[0].length =
  _dpsP[4].length =
  _dpsP[17].length = strlen(name);
  _dpsP[1].val.integerVal =
  _dpsP[15].val.integerVal = value;
  _dpsP[17].val.stringVal = _dps_offset;
  _dps_offset += _dpsP[17].length;
  _dpsP[4].val.stringVal = _dps_offset;
  _dps_offset += _dpsP[4].length;
  _dpsP[0].val.stringVal = _dps_offset;
  _dps_offset += _dpsP[0].length;

  _dpsF.nBytes = _dps_offset+8;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,152);
  DPSWriteStringChars(_dpsCurCtxt, (char *)name, _dpsP[17].length);
  DPSWriteStringChars(_dpsCurCtxt, (char *)name, _dpsP[4].length);
  DPSWriteStringChars(_dpsCurCtxt, (char *)name, _dpsP[0].length);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 804 "goodfile.psw"

#line 1920 "goodfile.c"
void PSWCharReturnStr(len, retStr)
int len; char *retStr; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    DPSBinObjGeneric obj8;
    DPSBinObjGeneric obj9;
    DPSBinObjGeneric obj10;
    DPSBinObjGeneric obj11;
    DPSBinObjGeneric obj12;
    DPSBinObjGeneric obj13;
    DPSBinObjGeneric obj14;
    DPSBinObjGeneric obj15;
    DPSBinObjGeneric obj16;
    DPSBinObjGeneric obj17;
    DPSBinObjGeneric obj18;
    DPSBinObjGeneric obj19;
    DPSBinObjGeneric obj20;
    DPSBinObjGeneric obj21;
    DPSBinObjGeneric obj22;
    DPSBinObjGeneric obj23;
    DPSBinObjGeneric obj24;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 16, 204,
    {DPS_LITERAL|DPS_NAME, 0, 0, 0},	/* str */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: len */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 165},	/* string */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 51},	/* def */
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: len */
    {DPS_EXEC|DPS_ARRAY, 0, 9, 128},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 72},	/* for */
    {DPS_EXEC|DPS_NAME, 0, 0, 0},	/* str */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 56},	/* dup */
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 169},	/* sub */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 62},	/* exch */
    {DPS_EXEC|DPS_NAME, 0, 0, 0},	/* str */
    {DPS_LITERAL|DPS_INT, 0, 0, 3},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 135},	/* roll */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 120},	/* put */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tChar, -1 },
    };
    _dpsR[0].count = -1;
    _dpsR[0].value = (char *)retStr;

  {
  static int _dpsT = 1;

  if (_dpsT) {
    static char *_dps_names[] = {
	"str",
	(char *) 0 ,
	(char *) 0 };
    long int *_dps_nameVals[3];
    _dps_nameVals[0] = (long int *)&_dpsP[0].val.nameVal;
    _dps_nameVals[1] = (long int *)&_dpsP[20].val.nameVal;
    _dps_nameVals[2] = (long int *)&_dpsP[9].val.nameVal;

    DPSMapNames(_dpsCurCtxt, 3, _dps_names, _dps_nameVals);
    _dpsT = 0;
    }
  }


  _dpsP[1].val.integerVal =
  _dpsP[6].val.integerVal = len;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,204);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 810 "goodfile.psw"

#line 2018 "goodfile.c"
void PSWCharReturnSeries(len, retStr)
int len; char *retStr; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    DPSBinObjGeneric obj8;
    DPSBinObjGeneric obj9;
    DPSBinObjGeneric obj10;
    DPSBinObjGeneric obj11;
    DPSBinObjGeneric obj12;
    DPSBinObjGeneric obj13;
    DPSBinObjGeneric obj14;
    DPSBinObjGeneric obj15;
    DPSBinObjGeneric obj16;
    DPSBinObjGeneric obj17;
    DPSBinObjGeneric obj18;
    DPSBinObjGeneric obj19;
    DPSBinObjGeneric obj20;
    DPSBinObjGeneric obj21;
    DPSBinObjGeneric obj22;
    DPSBinObjGeneric obj23;
    DPSBinObjGeneric obj24;
    DPSBinObjGeneric obj25;
    DPSBinObjGeneric obj26;
    DPSBinObjGeneric obj27;
    DPSBinObjGeneric obj28;
    DPSBinObjGeneric obj29;
    DPSBinObjGeneric obj30;
    char obj31[11];
    char obj32[22];
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 22, 285,
    {DPS_LITERAL|DPS_NAME, 0, 0, 0},	/* str */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: len */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 165},	/* string */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 51},	/* def */
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: len */
    {DPS_EXEC|DPS_ARRAY, 0, 9, 176},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 72},	/* for */
    {DPS_EXEC|DPS_NAME, 0, 0, 0},	/* str */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_STRING, 0, 22, 259},
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_STRING, 0, 11, 248},
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 56},	/* dup */
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 169},	/* sub */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 62},	/* exch */
    {DPS_EXEC|DPS_NAME, 0, 0, 0},	/* str */
    {DPS_LITERAL|DPS_INT, 0, 0, 3},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 135},	/* roll */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 120},	/* put */
    {'t','h','i','s',' ','e','i','t','h','e','r'},
    {'b','e','t','t','e','r',' ','n','o','t',' ','b','e',' ','r','e','t','u','r','n','e','d'},
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tChar, -1 },
    };
    _dpsR[0].count = -1;
    _dpsR[0].value = (char *)retStr;

  {
  static int _dpsT = 1;

  if (_dpsT) {
    static char *_dps_names[] = {
	"str",
	(char *) 0 ,
	(char *) 0 };
    long int *_dps_nameVals[3];
    _dps_nameVals[0] = (long int *)&_dpsP[0].val.nameVal;
    _dps_nameVals[1] = (long int *)&_dpsP[26].val.nameVal;
    _dps_nameVals[2] = (long int *)&_dpsP[9].val.nameVal;

    DPSMapNames(_dpsCurCtxt, 3, _dps_names, _dps_nameVals);
    _dpsT = 0;
    }
  }


  _dpsP[1].val.integerVal =
  _dpsP[6].val.integerVal = len;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,285);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 818 "goodfile.psw"

#line 2132 "goodfile.c"
void PSWCharReturnAry(in, len, chunk, retStr)
char *in; int len, chunk; char retStr[]; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char sizeFlag;
    unsigned short topLevelCount;
    unsigned long nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    DPSBinObjGeneric obj8;
    DPSBinObjGeneric obj9;
    DPSBinObjGeneric obj10;
    DPSBinObjGeneric obj11;
    DPSBinObjGeneric obj12;
    DPSBinObjGeneric obj13;
    DPSBinObjGeneric obj14;
    DPSBinObjGeneric obj15;
    DPSBinObjGeneric obj16;
    DPSBinObjGeneric obj17;
    DPSBinObjGeneric obj18;
    DPSBinObjGeneric obj19;
    DPSBinObjGeneric obj20;
    DPSBinObjGeneric obj21;
    DPSBinObjGeneric obj22;
    DPSBinObjGeneric obj23;
    DPSBinObjGeneric obj24;
    DPSBinObjGeneric obj25;
    DPSBinObjGeneric obj26;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 0, 16, 224,
    {DPS_LITERAL|DPS_NAME, 0, 0, 0},	/* chunks */
    {DPS_LITERAL|DPS_STRING, 0, 0, 216},	/* param in */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 98},	/* length */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: chunk */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 82},	/* idiv */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 51},	/* def */
    {DPS_LITERAL|DPS_NAME, 0, 0, 0},	/* byte */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 51},	/* def */
    {DPS_EXEC|DPS_NAME, 0, 0, 0},	/* chunks */
    {DPS_EXEC|DPS_ARRAY, 0, 11, 128},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 131},	/* repeat */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    {DPS_LITERAL|DPS_STRING, 0, 0, 216},	/* param in */
    {DPS_EXEC|DPS_NAME, 0, 0, 0},	/* byte */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: chunk */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 76},	/* getinterval */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_NAME, 0, 0, 0},	/* byte */
    {DPS_EXEC|DPS_NAME, 0, 0, 0},	/* byte */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: chunk */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 1},	/* add */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 51},	/* def */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  register int _dps_offset = 216;
  static DPSResultsRec _dpsR[] = {
    { dps_tChar },
    };
    _dpsR[0].count = len;
    _dpsR[0].value = (char *)retStr;

  {
  static int _dpsT = 1;

  if (_dpsT) {
    static char *_dps_names[] = {
	"chunks",
	(char *) 0 ,
	"byte",
	(char *) 0 ,
	(char *) 0 ,
	(char *) 0 };
    long int *_dps_nameVals[6];
    _dps_nameVals[0] = (long int *)&_dpsP[0].val.nameVal;
    _dps_nameVals[1] = (long int *)&_dpsP[9].val.nameVal;
    _dps_nameVals[2] = (long int *)&_dpsP[6].val.nameVal;
    _dps_nameVals[3] = (long int *)&_dpsP[23].val.nameVal;
    _dps_nameVals[4] = (long int *)&_dpsP[22].val.nameVal;
    _dps_nameVals[5] = (long int *)&_dpsP[17].val.nameVal;

    DPSMapNames(_dpsCurCtxt, 6, _dps_names, _dps_nameVals);
    _dpsT = 0;
    }
  }


  _dpsP[1].length =
  _dpsP[16].length = strlen(in);
  _dpsP[3].val.integerVal =
  _dpsP[18].val.integerVal =
  _dpsP[24].val.integerVal = chunk;
  _dpsP[16].val.stringVal = _dps_offset;
  _dps_offset += _dpsP[16].length;
  _dpsP[1].val.stringVal = _dps_offset;
  _dps_offset += _dpsP[1].length;

  _dpsF.nBytes = _dps_offset+8;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,224);
  DPSWriteStringChars(_dpsCurCtxt, (char *)in, _dpsP[16].length);
  DPSWriteStringChars(_dpsCurCtxt, (char *)in, _dpsP[1].length);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 827 "goodfile.psw"


#define CompareStr(exp, actual)\
  if (strcmp(exp, actual)) {\
    CmpError(exp, actual);\
    }

#define CompareStrAry(exp, actual, len)\
  if (strncmp(exp, actual, len)) {\
    CmpError(exp, actual);\
    }

/* Max string that can be passed in a wrap as a char * or
   array with dynamically declared bounds is NOT 65535 bytes
   long. This is due to pswrap building a binary object sequence
   whose length field is only 16 bits long. For our
   purposes, just use a fairly long string. */
#define MAX_PS_STRING 65535
#define LONG_PS_STRING 50000

#define MAX_NAME_LEN 127

void CharacterStrings()
  {
  char	charStr[MAX_PS_STRING+1], rCharStr[MAX_PS_STRING+1];
  int	i, len, chunk;
  Bool gotException = False;

  /* Case 1 */

  for( i = 0; i < LONG_PS_STRING; i++)
    charStr[i] = '0';
  charStr[i] = '\0';
  DoWrap(PSWCharStringRoundTrip, (charStr, rCharStr));
  CompareStr(charStr, rCharStr);

  DoWrap(PSWCharStaticArrayRoundTrip, (charStr, rCharStr));
  CompareStrAry(charStr, rCharStr, 10);

  DoWrap(PSWCharVarArrayRoundTrip, (charStr, LONG_PS_STRING, rCharStr));
  CompareStrAry(charStr, rCharStr, LONG_PS_STRING);

  /* Case 2 */

  (void) strcpy(charStr, "A name");
  DoWrap(PSWCharStrAsName, (charStr, 10, &i));
  Compare(10, i, "%d");

  for( i = 0; i < MAX_NAME_LEN; i++)
    charStr[i] = '0';
  charStr[i] = '\0';
  DoWrap(PSWCharStrAsName, (charStr, 10, &i));
  Compare(10, i, "%d");

#ifdef BUG
  DURING
    for( i = 0; i <= MAX_NAME_LEN; i++)
      charStr[i] = '0';
    charStr[i] = '\0';
    DoWrap(PSWCharStrAsName, (charStr, 10, &i));
  HANDLER
    if (Exception.Code != dps_err_nameTooLong)
      RERAISE;
    gotException = True;
    PSWCleanup();
  END_HANDLER

  if (!gotException)
    Error("expected name too long error - none occurred");
#endif BUG

  /* Case 3 */

  len = 0;
  DoWrap(PSWCharReturnStr, (len, rCharStr));
  charStr[len] = '\0';
  CompareStrAry(charStr, rCharStr, len+1);

  len = 255;
  DoWrap(PSWCharReturnStr, (len, rCharStr));
  for (i = 0; i < len; i++)
    charStr[i] = i + 1;
  charStr[len] = '\0';
  CompareStrAry(charStr, rCharStr, len+1);

  DoWrap(PSWCharReturnSeries, (len, rCharStr));
  CompareStrAry(charStr, rCharStr, len+1);

  /* Case 4 - all variants use the same 10 byte input string
     but vary the "len" of the return string and the "chunk"
     size of substrings of the input string to return. */

  (void) strcpy(charStr, "0123456789");
  len = 10;
  chunk = 10;
  DoWrap(PSWCharReturnAry, (charStr, len, chunk, rCharStr));
  CompareStrAry(charStr, rCharStr, len);

  (void) strcpy(rCharStr, "----------");
  len = 9;
  chunk = 5;
  DoWrap(PSWCharReturnAry, (charStr, len, chunk, rCharStr));
  CompareStr("012345678-", rCharStr);

  (void) strcpy(rCharStr, "----------");
  len = 6;
  chunk = 5;
  DoWrap(PSWCharReturnAry, (charStr, len, chunk, rCharStr));
  CompareStr("012345----", rCharStr);

  (void) strcpy(rCharStr, "----------");
  len = 11;
  chunk = 3;
  DoWrap(PSWCharReturnAry, (charStr, len, chunk, rCharStr));
  CompareStr("012345678-", rCharStr);

  }


/*==================================================================
 TEST: Arrays
 DESCRIPTION:
   Tests correct operation of wraps accepting arrays as input 
   parameters and returning arrays as output parameters. Types 
   of tests include: basic 'echo' testing, accessing individual
   elements of an array, returning a series of array elements, 
   and arrays declared with both static and dynamic bounds.
   
 TESTS:
   BASIC OPERATION:
	Case 1: --- Basic round-trip tests ---
		Integer arrays with bounds up to the maximum PS 
		array limit are passed to a wrap which returns 
		the array as its result. The same test is 
		performed using arrays of statically and dynamically
		declared length.
	Case 2:	--- Accessing individual array elements ---
		A wrap that returns the 0th and 1st elements
		of the specified integer array is called. The
		returned values are checked against the known
		array elements.
	Case 3:	--- Returning array elements one by one ---
		A wrap that accepts an integer array with static
		bounds and an element count, and returns an array 
		with dynamic bounds is defined. Its function is
		to iteratively get an element from the input
		array and store it in the return array (up to the
		specified element count). It is called with
		varying element count and size of output array
		such that:
		- the number of elements exactly fills the output
		  array.
		- the number of elements returned is less that the
		  size of the output array. "Unreturned" elements
		  in the output array are verified to ensure they
		  have not been smashed.
		- the number of elements returned is greater than
		  the size of the output array. Elements of the
		  output array beyond the bounds declared to the
		  wrap are checked to ensure they were not smashed.
	Case 4:	--- Returning a series of array elements ---
		A wrap that accepts an integer array with dynamic
		bounds and a "return chunk" size as input parameters,
		and returns an array with dynamically specified bounds
		is called with 3 different sets of parameters:
		- the input array, return chunk size, and output
		  array bounds make the wrap return an array the
		  same size as the input array - the data is
		  stored in the array in one reference.
		- the input array, return chunk size, and output
		  array bounds make the wrap return an array shorter
		  than the input array. The wrap attempts to store
		  results in the output array in two chunks; the
		  first chunk fits, and all but the last element of
		  the second chunk fits.
		- the input array, return chunk size, and output
		  array bounds make the wrap return an array longer
		  than the input array. The result data is stored
		  in 3 chunks; the returned array is checked to
		  ensure that elements beyond those explicitly returned
		  by the wrap have not been overwritten.
 NOT TESTED:
	Passing array longer than size allowed by PS.
 END TEST DESCRIPTION
===================================================================*/
#line 2437 "goodfile.c"
void PSWStaticArrayRoundTrip(in, out)
int in[]; int out[]; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 140,
    {DPS_LITERAL|DPS_ARRAY, 0, 10, 56},	/* param[const]: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  static DPSResultsRec _dpsR[] = {
    { dps_tInt },
    };
    _dpsR[0].count = 10;
    _dpsR[0].value = (char *)out;

  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSWriteTypedObjectArray(_dpsCurCtxt, dps_tInt, (char *)in, 10);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 1015 "goodfile.psw"

#line 2478 "goodfile.c"
void PSWVarArrayRoundTrip(in, l, out)
int in[]; int l; int out[]; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_LITERAL|DPS_ARRAY, 0, 0, 56},	/* param[var]: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  register int _dps_offset = 56;
  static DPSResultsRec _dpsR[] = {
    { dps_tInt },
    };
    _dpsR[0].count = l;
    _dpsR[0].value = (char *)out;


  _dpsP[0].length = l;
  _dpsP[0].val.arrayVal = _dps_offset;
  _dps_offset += l * sizeof(DPSBinObjGeneric);

  _dpsF.nBytes = _dps_offset+4;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,60);
  DPSWriteTypedObjectArray(_dpsCurCtxt, dps_tInt, (char *)in, l);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 1019 "goodfile.psw"

#line 2527 "goodfile.c"
void PSWArrayRet2Elements(in, a, b)
int in[]; int *a, *b; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    DPSBinObjGeneric obj8;
    DPSBinObjGeneric obj9;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 10, 84,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* indexed param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* indexed param: in */
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 2},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  static DPSResultsRec _dpsR[] = {
    { dps_tInt, -1 },
    { dps_tInt, -1 },
    };
    _dpsR[0].value = (char *)a;
    _dpsR[1].value = (char *)b;


  _dpsP[0].val.integerVal = in[0];
  _dpsP[3].val.integerVal = in[1];
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 2);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,84);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 1023 "goodfile.psw"

#line 2578 "goodfile.c"
void PSWArrayRetElements(in, elements, len, retAry)
int in[]; int elements, len; int retAry[]; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    DPSBinObjGeneric obj8;
    DPSBinObjGeneric obj9;
    DPSBinObjGeneric obj10;
    DPSBinObjGeneric obj11;
    DPSBinObjGeneric obj12;
    DPSBinObjGeneric obj13;
    DPSBinObjGeneric obj14;
    DPSBinObjGeneric obj15;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 11, 292,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: elements */
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 169},	/* sub */
    {DPS_EXEC|DPS_ARRAY, 0, 5, 88},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 72},	/* for */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    {DPS_LITERAL|DPS_ARRAY, 0, 20, 128},	/* param[const]: in */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 62},	/* exch */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 75},	/* get */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  register int _dps_offset = 128;
  static DPSResultsRec _dpsR[] = {
    { dps_tInt },
    };
    _dpsR[0].count = len;
    _dpsR[0].value = (char *)retAry;


  _dpsP[2].val.integerVal = elements;
  _dpsP[11].val.arrayVal = _dps_offset;
  _dps_offset += 20 * sizeof(DPSBinObjGeneric);

  _dpsF.nBytes = _dps_offset+4;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,132);
  DPSWriteTypedObjectArray(_dpsCurCtxt, dps_tInt, (char *)in, 20);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 1030 "goodfile.psw"

#line 2645 "goodfile.c"
void PSWArrayRetSeries(in, len, chunk, retAry)
int in[]; int len, chunk; int retAry[]; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    DPSBinObjGeneric obj8;
    DPSBinObjGeneric obj9;
    DPSBinObjGeneric obj10;
    DPSBinObjGeneric obj11;
    DPSBinObjGeneric obj12;
    DPSBinObjGeneric obj13;
    DPSBinObjGeneric obj14;
    DPSBinObjGeneric obj15;
    DPSBinObjGeneric obj16;
    DPSBinObjGeneric obj17;
    DPSBinObjGeneric obj18;
    DPSBinObjGeneric obj19;
    DPSBinObjGeneric obj20;
    DPSBinObjGeneric obj21;
    DPSBinObjGeneric obj22;
    DPSBinObjGeneric obj23;
    DPSBinObjGeneric obj24;
    DPSBinObjGeneric obj25;
    DPSBinObjGeneric obj26;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 16, 380,
    {DPS_LITERAL|DPS_NAME, 0, 0, 0},	/* chunks */
    {DPS_LITERAL|DPS_ARRAY, 0, 10, 296},	/* param[const]: in */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 98},	/* length */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: chunk */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 82},	/* idiv */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 51},	/* def */
    {DPS_LITERAL|DPS_NAME, 0, 0, 0},	/* element */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 51},	/* def */
    {DPS_EXEC|DPS_NAME, 0, 0, 0},	/* chunks */
    {DPS_EXEC|DPS_ARRAY, 0, 11, 128},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 131},	/* repeat */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    {DPS_LITERAL|DPS_ARRAY, 0, 10, 216},	/* param[const]: in */
    {DPS_EXEC|DPS_NAME, 0, 0, 0},	/* element */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: chunk */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 76},	/* getinterval */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_NAME, 0, 0, 0},	/* element */
    {DPS_EXEC|DPS_NAME, 0, 0, 0},	/* element */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: chunk */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 1},	/* add */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 51},	/* def */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  register int _dps_offset = 216;
  static DPSResultsRec _dpsR[] = {
    { dps_tInt },
    };
    _dpsR[0].count = len;
    _dpsR[0].value = (char *)retAry;

  {
  static int _dpsT = 1;

  if (_dpsT) {
    static char *_dps_names[] = {
	"chunks",
	(char *) 0 ,
	"element",
	(char *) 0 ,
	(char *) 0 ,
	(char *) 0 };
    long int *_dps_nameVals[6];
    _dps_nameVals[0] = (long int *)&_dpsP[0].val.nameVal;
    _dps_nameVals[1] = (long int *)&_dpsP[9].val.nameVal;
    _dps_nameVals[2] = (long int *)&_dpsP[6].val.nameVal;
    _dps_nameVals[3] = (long int *)&_dpsP[23].val.nameVal;
    _dps_nameVals[4] = (long int *)&_dpsP[22].val.nameVal;
    _dps_nameVals[5] = (long int *)&_dpsP[17].val.nameVal;

    DPSMapNames(_dpsCurCtxt, 6, _dps_names, _dps_nameVals);
    _dpsT = 0;
    }
  }


  _dpsP[3].val.integerVal =
  _dpsP[18].val.integerVal =
  _dpsP[24].val.integerVal = chunk;
  _dpsP[16].val.arrayVal = _dps_offset;
  _dps_offset += 10 * sizeof(DPSBinObjGeneric);
  _dpsP[1].val.arrayVal = _dps_offset;
  _dps_offset += 10 * sizeof(DPSBinObjGeneric);

  _dpsF.nBytes = _dps_offset+4;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 1);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,220);
  DPSWriteTypedObjectArray(_dpsCurCtxt, dps_tInt, (char *)in, 10);
  DPSWriteTypedObjectArray(_dpsCurCtxt, dps_tInt, (char *)in, 10);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 1040 "goodfile.psw"


#define CompareArray(exp, actual, len)\
  for (i = 0; i < len; i++) { \
    Compare(exp[i], actual[i], "%d");\
    }

/* Max array that can be passed in a wrap with dynamically 
   declared bounds is NOT 65535 elements
   long. This is due to pswrap building a binary object sequence
   whose length field is only 16 bits long. For our
   purposes, just use a fairly long array. */
#define MAX_PS_ARRAY 65535
#define LONG_PS_ARRAY 5000

static void ZeroArray(a, len)
  int	a[];
  int	len;
  {
  int	i;

  for (i = 0; i < len; i++)
    a[i] = 0;
  }

static void SetExpArray(a, fill, zero)
  int	a[];
  int	fill, zero;
  {
  int	i;

  for (i = 0; i < zero; i++)
    if (i < fill)
      a[i] = i;
    else
      a[i] = 0;
  }

void Arrays()
  {
  static int	array[MAX_PS_ARRAY+1], rArray[MAX_PS_ARRAY+1];
  int	expArray[20];
  int	i, len, elements, chunk;

  for (i = 0; i < LONG_PS_ARRAY; i++)
    array[i] = i;

  /* Case 1 */

  DoWrap(PSWStaticArrayRoundTrip, (array, rArray));
  CompareArray(array, rArray, 10);

  DoWrap(PSWVarArrayRoundTrip, (array, LONG_PS_ARRAY, rArray));
  CompareArray(array, rArray, LONG_PS_ARRAY);

  /* Case 2 */

  DoWrap(PSWArrayRet2Elements, (array, &i, &len));
  Compare(array[0], i, "%d");
  Compare(array[1], len, "%d");

  /* Case 3 */

  elements = len = 10;
  DoWrap(PSWArrayRetElements, (array, elements, len, rArray));
  CompareArray(array, rArray, elements);

  elements = 9;
  len = 10;
  rArray[elements] = 0;
  DoWrap(PSWArrayRetElements, (array, elements, len, rArray));
  CompareArray(array, rArray, elements);
  Compare(0, rArray[elements], "%d");

  elements = 11;
  len = 10;
  rArray[len] = 0;
  DoWrap(PSWArrayRetElements, (array, elements, len, rArray));
  CompareArray(array, rArray, len);
  Compare(0, rArray[len], "%d");

  /* Case 4 - all variants use the same 10 element input array
     but vary the "len" of the return array and the "chunk"
     size of subarrays of the input array to return. */

  len = 10;
  chunk = 10;
  DoWrap(PSWArrayRetSeries, (array, len, chunk, rArray));
  CompareArray(array, rArray, len);

  len = 9;
  chunk = 5;
  ZeroArray(rArray, 10); SetExpArray(expArray, len, 10);
  DoWrap(PSWArrayRetSeries, (array, len, chunk, rArray));
  CompareArray(expArray, rArray, 10);
  
  len = 6;
  chunk = 5;
  ZeroArray(rArray, 10); SetExpArray(expArray, len, 10);
  DoWrap(PSWArrayRetSeries, (array, len, chunk, rArray));
  CompareArray(expArray, rArray, 10);

  len = 11;
  chunk = 3;
  ZeroArray(rArray, 11); SetExpArray(expArray, 9, 11);
  DoWrap(PSWArrayRetSeries, (array, len, chunk, rArray));
  CompareArray(expArray, rArray, len);

  }


/*==================================================================
 TEST: Context IDs
 DESCRIPTION:
   Tests that invoking a wrap whose first input parameter is
   declared as type DPScontext directs execution of the wrap 
   to the specified context.
 TESTS:
   BASIC OPERATION:
	Case 1: --- Execution of same wraps by different contexts ---
		Two contexts are created. The first one then
		executes a wrap that changes its gray level to .5
		and the second sets its level to .75. Each context
		is then directed to execute a wrap to return its
		gray level. The returned gray levels are compared
		to expected levels; if they match, it is apparent
		that the DPSContext parameters in the 2 wraps
		had the desired effect.
 NOT TESTED:
	None.
 END TEST DESCRIPTION
===================================================================*/
#line 2894 "goodfile.c"
void PSWSetGray(c, gray)
DPSContext c; float gray; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjReal obj0;
    DPSBinObjGeneric obj1;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 2, 20,
    {DPS_LITERAL|DPS_REAL, 0, 0, 0},	/* param: gray */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 150},	/* setgray */
    }; /* _dpsQ */
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;

  _dpsP[0].val.realVal = gray;
  DPSBinObjSeqWrite(c,(char *) &_dpsF,20);
}
#line 1175 "goodfile.psw"

#line 2918 "goodfile.c"
void PSWGetGray(c, gray)
DPSContext c; float *gray; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char topLevelCount;
    unsigned short nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 7, 60,
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 33},	/* currentgray */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  static DPSResultsRec _dpsR[] = {
    { dps_tFloat, -1 },
    };
    _dpsR[0].value = (char *)gray;

  DPSSetResultTable(c, _dpsR, 1);
  DPSBinObjSeqWrite(c,(char *) &_dpsF,60);
  DPSAwaitReturnValues(c);
}
#line 1179 "goodfile.psw"


void ContextIDs()
  {
  DPSContext	ctxt1, ctxt2;
  float		g, c1g, c2g;

  ctxt1 = CreateContext();
  ctxt2 = CreateContext();

  c1g = 0.5; c2g = 0.75;
  DoWrap(PSWSetGray, (ctxt1, c1g));
  DoWrap(PSWSetGray, (ctxt2, c2g));

  DoWrap(PSWGetGray, (ctxt1, &g));
  Compare(c1g, g, "%f");

  DoWrap(PSWGetGray, (ctxt2, &g));
  Compare(c2g, g, "%f");

  }

/*==================================================================
 TEST: Returning mixed types
 DESCRIPTION:
   Tests wraps that return different types of parameters.
 TESTS:
   BASIC OPERATION:
	Case 1: --- Echo all types ---
		A wrap that accepts input parameters of all valid 
		"return parameter types" and returns those
		input parameters without modification is called.
		The return parameters are verified for correct
		contents.
 NOT TESTED:
	None.
 END TEST DESCRIPTION
===================================================================*/
#line 2993 "goodfile.c"
void PSWEchoAll(s, i, l, us, ui, ul, f, d, b, str, chrStAry, chrVarAry, stAry, varAry, sR, iR, lR, usR, uiR, ulR, fR, dR, bR, strR, chrStAryR, chrVarAryR, stAryR, varAryR)
short int s; int i; long int l; unsigned short int us; unsigned int ui; unsigned long int ul; float f; double d; int b; char *str; char chrStAry[]; char chrVarAry[]; float stAry[]; double varAry[]; short int *sR; int *iR; long int *lR; unsigned short int *usR; unsigned int *uiR; unsigned long int *ulR; float *fR; double *dR; int *bR; char *strR; char chrStAryR[]; char chrVarAryR[]; float stAryR[]; double varAryR[]; 
{
  typedef struct {
    unsigned char tokenType;
    unsigned char sizeFlag;
    unsigned short topLevelCount;
    unsigned long nBytes;

    DPSBinObjGeneric obj0;
    DPSBinObjGeneric obj1;
    DPSBinObjGeneric obj2;
    DPSBinObjGeneric obj3;
    DPSBinObjGeneric obj4;
    DPSBinObjGeneric obj5;
    DPSBinObjGeneric obj6;
    DPSBinObjGeneric obj7;
    DPSBinObjGeneric obj8;
    DPSBinObjGeneric obj9;
    DPSBinObjGeneric obj10;
    DPSBinObjGeneric obj11;
    DPSBinObjGeneric obj12;
    DPSBinObjGeneric obj13;
    DPSBinObjGeneric obj14;
    DPSBinObjGeneric obj15;
    DPSBinObjGeneric obj16;
    DPSBinObjGeneric obj17;
    DPSBinObjReal obj18;
    DPSBinObjGeneric obj19;
    DPSBinObjGeneric obj20;
    DPSBinObjReal obj21;
    DPSBinObjGeneric obj22;
    DPSBinObjGeneric obj23;
    DPSBinObjGeneric obj24;
    DPSBinObjGeneric obj25;
    DPSBinObjGeneric obj26;
    DPSBinObjGeneric obj27;
    DPSBinObjGeneric obj28;
    DPSBinObjGeneric obj29;
    DPSBinObjGeneric obj30;
    DPSBinObjGeneric obj31;
    DPSBinObjGeneric obj32;
    DPSBinObjGeneric obj33;
    DPSBinObjGeneric obj34;
    DPSBinObjGeneric obj35;
    DPSBinObjGeneric obj36;
    DPSBinObjGeneric obj37;
    DPSBinObjGeneric obj38;
    DPSBinObjGeneric obj39;
    DPSBinObjGeneric obj40;
    DPSBinObjGeneric obj41;
    DPSBinObjGeneric obj42;
    DPSBinObjGeneric obj43;
    DPSBinObjGeneric obj44;
    DPSBinObjGeneric obj45;
    } _dpsQ;
  static _dpsQ _dpsF = {
    DPS_DEF_TOKENTYPE, 0, 46, 549,
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: s */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: i */
    {DPS_LITERAL|DPS_INT, 0, 0, 1},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: l */
    {DPS_LITERAL|DPS_INT, 0, 0, 2},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: us */
    {DPS_LITERAL|DPS_INT, 0, 0, 3},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: ui */
    {DPS_LITERAL|DPS_INT, 0, 0, 4},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},	/* param: ul */
    {DPS_LITERAL|DPS_INT, 0, 0, 5},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_REAL, 0, 0, 0},	/* param: f */
    {DPS_LITERAL|DPS_INT, 0, 0, 6},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_REAL, 0, 0, 0},	/* param: d */
    {DPS_LITERAL|DPS_INT, 0, 0, 7},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_BOOL, 0, 0, 0},	/* param: b */
    {DPS_LITERAL|DPS_INT, 0, 0, 8},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_STRING, 0, 0, 541},	/* param str */
    {DPS_LITERAL|DPS_INT, 0, 0, 9},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_STRING, 0, 13, 528},	/* param[const]: chrStAry */
    {DPS_LITERAL|DPS_INT, 0, 0, 10},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_STRING, 0, 0, 528},	/* param chrVarAry */
    {DPS_LITERAL|DPS_INT, 0, 0, 11},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_ARRAY, 0, 20, 368},	/* param[const]: stAry */
    {DPS_LITERAL|DPS_INT, 0, 0, 12},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_ARRAY, 0, 0, 368},	/* param[var]: varAry */
    {DPS_LITERAL|DPS_INT, 0, 0, 13},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_LITERAL|DPS_INT, 0, 0, 0},
    {DPS_LITERAL|DPS_INT, 0, 0, 14},
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 119},	/* printobject */
    {DPS_EXEC|DPS_NAME, 0, DPSSYSNAME, 70},	/* flush */
    }; /* _dpsQ */
  register DPSContext _dpsCurCtxt = DPSPrivCurrentContext();
  register DPSBinObjRec *_dpsP = (DPSBinObjRec *)&_dpsF.obj0;
  register int _dps_offset = 368;
  static DPSResultsRec _dpsR[] = {
    { dps_tShort, -1 },
    { dps_tInt, -1 },
    { dps_tLong, -1 },
    { dps_tUShort, -1 },
    { dps_tUInt, -1 },
    { dps_tULong, -1 },
    { dps_tFloat, -1 },
    { dps_tDouble, -1 },
    { dps_tBoolean, -1 },
    { dps_tChar, -1 },
    { dps_tChar },
    { dps_tChar },
    { dps_tFloat },
    { dps_tDouble },
    };
    _dpsR[0].value = (char *)sR;
    _dpsR[1].value = (char *)iR;
    _dpsR[2].value = (char *)lR;
    _dpsR[3].value = (char *)usR;
    _dpsR[4].value = (char *)uiR;
    _dpsR[5].value = (char *)ulR;
    _dpsR[6].value = (char *)fR;
    _dpsR[7].value = (char *)dR;
    _dpsR[8].value = (char *)bR;
    _dpsR[9].count = -1;
    _dpsR[9].value = (char *)strR;
    _dpsR[10].count = 13;
    _dpsR[10].value = (char *)chrStAryR;
    _dpsR[11].count = i;
    _dpsR[11].value = (char *)chrVarAryR;
    _dpsR[12].count = 20;
    _dpsR[12].value = (char *)stAryR;
    _dpsR[13].count = i;
    _dpsR[13].value = (char *)varAryR;


  _dpsP[0].val.integerVal = s;
  _dpsP[3].val.integerVal = i;
  _dpsP[6].val.integerVal = l;
  _dpsP[9].val.integerVal = us;
  _dpsP[12].val.integerVal = ui;
  _dpsP[15].val.integerVal = ul;
  _dpsP[18].val.realVal = f;
  _dpsP[21].val.realVal = d;
  _dpsP[24].val.booleanVal = (long) (0 != b);
  _dpsP[27].length = strlen(str);
  _dpsP[30].length = 13;
  _dpsP[33].length = i;
  _dpsP[39].length = i;
  _dpsP[39].val.arrayVal = _dps_offset;
  _dps_offset += i * sizeof(DPSBinObjGeneric);
  _dpsP[36].val.arrayVal = _dps_offset;
  _dps_offset += 20 * sizeof(DPSBinObjGeneric);
  _dpsP[33].val.stringVal = _dps_offset;
  _dps_offset += i;
  _dpsP[30].val.stringVal = _dps_offset;
  _dps_offset += 13;
  _dpsP[27].val.stringVal = _dps_offset;
  _dps_offset += _dpsP[27].length;

  _dpsF.nBytes = _dps_offset+8;
  DPSSetResultTable(_dpsCurCtxt, _dpsR, 14);
  DPSBinObjSeqWrite(_dpsCurCtxt,(char *) &_dpsF,376);
  DPSWriteTypedObjectArray(_dpsCurCtxt, dps_tDouble, (char *)varAry, i);
  DPSWriteTypedObjectArray(_dpsCurCtxt, dps_tFloat, (char *)stAry, 20);
  DPSWriteStringChars(_dpsCurCtxt, (char *)chrVarAry, i);
  DPSWriteStringChars(_dpsCurCtxt, (char *)chrStAry, 13);
  DPSWriteStringChars(_dpsCurCtxt, (char *)str, _dpsP[27].length);
  DPSAwaitReturnValues(_dpsCurCtxt);
}
#line 1237 "goodfile.psw"


void CompareRealArray(exp, actual, len)
  float	exp[], actual[];
  int	len;
  {
  int i;
  for (i = 0; i < len; i++) 
    CompareReal(exp[i], actual[i]);
  }

void CompareDoubleArray(exp, actual, len)
  double	exp[], actual[];
  int		len;
  {
#define ERROR 0.001
  int i;
  double d;
  for (i = 0; i < len; i++) { 
    d = exp[i] - actual[i];
    d = d < 0.0 ? -d : d;
    if ((d < -ERROR) || (d > ERROR)) {
      char expStr[32], actualStr[32];
      (void) sprintf(expStr, "%g", exp[i]);
      (void) sprintf(actualStr, "%g", actual[i]);
      CmpError(expStr, actualStr);
      }
    }
  }
      

void ReturnMixed()
  {
  int j;
  short s = 32767; int i = 10; long l = GenMax(sizeof(long));
  short sR; int iR; long lR;
  unsigned short us = 65535; unsigned ui = 20; unsigned long ul = 1 << 31;
  unsigned short usR; unsigned uiR; unsigned long ulR;
  float f = 6.02e23; double d = -f;
  float fR; double dR;
  int /* boolean */ b = True;
  int /* boolean */ bR;
  char *str; char chrStAry[13]; char chrVarAry[10];
  char strR[20]; char chrStAryR[20]; char chrVarAryR[20];
  float stAry[20]; double varAry[10];
  float stAryR[20]; double varAryR[10];

  str = "character string";
  (void) strcpy(chrStAry, "13 characters");
  (void) strcpy(chrVarAry, "0123456789");

  for (j = 0; j < 20; j++)
    stAry[j] = j * 3.1415;

  for (j = 0; j < 10; j++)
    varAry[j] = j * 6.02;

  wrapName = "PSWEchoAll";
  if (optionTrace) TraceWrapName();
  PSWEchoAll(s, i, l, us, ui, ul, f, d, b, 
	 str, chrStAry, chrVarAry, stAry, varAry,
         &sR, &iR, &lR, &usR, &uiR, &ulR, &fR, &dR, &bR,
	 strR, chrStAryR, chrVarAryR, stAryR, varAryR);

  Compare(s, sR, "%d");
  Compare(i, iR, "%d");
  Compare(l, lR, "%ld");
  Compare(us, usR, "%d");
  Compare(ui, uiR, "%d");
  Compare(ul, ulR, "%ld");
  CompareReal(f, fR);
  CompareReal(d, dR);
  CompareStr(str, strR);
  CompareStrAry(chrStAry, chrStAryR, 13);
  CompareStrAry(chrVarAry, chrVarAryR, 10);
  CompareRealArray(stAry, stAryR, 20);
  CompareDoubleArray(varAry, varAryR, 10);

  }

void RunTest(tstProc)
  void	(*tstProc)();
  {
  testName = "";
  DURING
    (*tstProc)();
  HANDLER
    /* This is the outermost exception handler */
    errCount++;
    if (Exception.Code == dps_err_ps)
      DPSResetContext((DPSContext)Exception.Message);
    else {
      /* If not a ps error, Default handler never got a look
	 at it (see the AppErrorProc to understand why). Call
	 the default handler now, passing the args saved by
	 AppErrorProc. */
      Error("");
      DPSDefaultErrorProc((DPSContext) Exception.Message, 
	Exception.Code, saveExceptionArg1, saveExceptionArg2);
      }
  END_HANDLER
  }

/* Array of pointers to test procedures */

void	(*testProcs[])() = {
  Booleans
 ,UserObjects
 ,Integers
 ,Reals
 ,CharacterStrings
 ,Arrays
 ,ContextIDs
 ,ReturnMixed
 ,NULL
 };

main(argc, argv)
  int argc;
  char **argv;
  {
  int		i;
  char 		st[LINEBUF];

  GetCommandLineOptions(&argc, &argv);
    
    dpy = XOpenDisplay(NULL);
    if (dpy == NULL) {
      fprintf(stderr, "Unable to open display\n");
      CleanUpAndExit(SYS_ERROR);
      }

  /* Create context */

  context = CreateContext();
        
  DPSSetTextBackstop(AppTextProc);
  DPSSetContext(context);
  DPSPrintf(context, "resyncstart\n");
  if (doAscii) {
    fdcontext = DPSCreateTextContext(AppTextProc, AppErrorProc);
    DPSChainContext(context,fdcontext);
    }

  if (! doAscii) printf("Begin test ...\n");
    
  /* Execute each test within an exception handler to allow
     the entire suite to execute past errors in individual tests */

  for (i = 0; testProcs[i] != NULL; i++)
    RunTest(testProcs[i]);

  /* Disconnect from DPS server */
    
  fprintf(stderr,"End test ...\n");
	
  CleanUpAndExit(0);
  }
