/*
 * goodfile.psw
 *
 * Copyright (C) 1988, 1989 by Adobe Systems Incorporated.
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notices appear in all copies and that
 * both those copyright notices and this permission notice appear in
 * supporting documentation and that the name of Adobe Systems
 * Incorporated not be used in advertising or publicity pertaining to
 * distribution of the software without specific, written prior
 * permission.  If any portion of this software is changed, it cannot be
 * marketed under Adobe's trademarks and/or copyrights unless Adobe, in
 * its sole discretion, approves by a prior writing the quality of the
 * resulting implementation.
 * 
 * ADOBE MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THE SOFTWARE FOR
 * ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
 * ADOBE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO EVENT SHALL ADOBE BE LIABLE
 * TO YOU OR ANY OTHER PARTY FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE, STRICT LIABILITY OR ANY OTHER ACTION ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ADOBE WILL NOT
 * PROVIDE ANY TRAINING OR OTHER SUPPORT FOR THE SOFTWARE.
 * 
 * PostScript, Display PostScript, and Adobe are trademarks of Adobe Systems
 * Incorporated registered in the U.S.A. and other countries.
 *
 * Author: Adobe Systems Incorporated
 */

/*Purpose: Test pswrap: ability to pass all types of arguments
 *	to and from wrapped procedures, some pswrap scanner tests.
 *
 *Scope: 
 *	This suite mainly tests the parameter passing and type
 * 	conversion capabilities of code generated by pswrap; it
 *	tests pswrap in an indirect manner by 'testing' this
 *	generated code. There are other tests which judge pswrap's
 *	ability to detect various error conditions and correctly
 *	report them. Some errors detected at runtime (type mismatches)
 *	are forced.
 *
 *Functionality: 
 *	See individual test descriptions.
 *
 *StandAlone: true
 *
 *Usage:
 *	goodfile [-a -t]
 *	-a	Create a chained FILE context to log all output
 *		to the server to stdout or a file.
 *	-t	Trace: write the name of each wrap to stdout just
 *		before it is executed.
 */

#include <stdio.h>

#include <DPS/dpsclient.h>
#include <DPS/dpsXclient.h>
#include <DPS/dpsexcept.h>

#define LINEBUF 256

#define stdin_fd 0
#define stdout_fd 1

#define VOID (void)

/* exit errors (MPW conventions) */
#define NO_ERROR 0
#define CMDLINE_ERROR 1
#define PROG_ERROR 2	/* PS error */
#define SYS_ERROR 3

#define DoWrap(wrap,args) \
    wrapName = "wrap"; \
    if (optionTrace) TraceWrapName(); \
    wrap args, \
    DPSWaitContext(context)

typedef	long int Userobject;

/* Global Vars */

Bool		optionTrace,	/* write wrap names to stdout */
		doAscii,
		doStrings;
char 		*prog;		/* program name */
char 		*wrapName;	/* current wrap name */
char		*testName;	/* current test name */
char		*chainedFile;	/* name of file for chained File context */
DPSContext      context;        /* Context holder. */
DPSContext      fdcontext;      /* Chained Context holder. */
int		errCount;	/* number of tests ending in error */
unsigned long	saveExceptionArg1,
		saveExceptionArg2;
FILE		*textFd = stderr; /* FD to write returned text to */
Display		*dpy;		/* X display structure */

/* Utility procedures */

static void CleanUpAndExit(exitCode)
  int exitCode;
  {
  if (context)
    DPSDestroySpace(DPSSpaceFromContext(context));
  exit (exitCode);
  }

/* Command line parser - sets state of global variables as
   appropriate */

void GetCommandLineOptions(pArgc, pArgv)
  int	*pArgc;
  char	**pArgv[];
  {
  int	argc = *pArgc;
  char	**argv;
  char	*argP;

  argv = *pArgv;
  prog = *argv;
  ++argv;
  --argc;
    
  while (argc > 0 && **argv == '-') {
    argP = *argv;
    switch (argP[1]) {
      case 't':	/* trace wrap execution */
        optionTrace = True; break;
      case 'a': 
        doAscii = True; 
	if ((argc > 1) && (**(argv+1) != '-')) {
          argv++; argc--;
          if ((textFd = fopen(*argv, "w")) == NULL) {
            VOID fprintf(stderr, "pswtest: can't open file (%s)\n", *argv);
            CleanUpAndExit(CMDLINE_ERROR);
            }
	  }
	break;
      default:
        fprintf(stderr, "Unknown option %s\n", argP);
        CleanUpAndExit(CMDLINE_ERROR);
      }
    argv++;
    argc--;
    }

  *pArgc = argc;
  *pArgv = argv;
  }


static void Error(msg)
  char *	msg;	/* error message */
  {
  fprintf(stderr, "Error in %s wrap: %s\n", wrapName, msg);
  }

static void CmpError(exp, actual)
  char *	exp;	/* expected value */
  char *	actual;	/* actual value */
  {
  Error(testName);
  fprintf(stderr, "  Expected result:\n    %s\n  Got:\n    %s\n",
    exp, actual);
  }


#define Compare(exp, actual, format)\
  if (exp != actual) {\
    char expStr[32], actualStr[32];\
    (void) sprintf(expStr, format, exp);\
    (void) sprintf(actualStr, format, actual);\
    CmpError(expStr, actualStr);\
    }

#define CompareReal(exp, actual)\
  if (exp != actual) {\
    char expStr[32], actualStr[32];\
    (void) sprintf(expStr, "%g", exp);\
    (void) sprintf(actualStr, "%g", actual);\
    CmpError(expStr, actualStr);\
    }

static void CompareDouble(exp, actual)
  double	exp, actual;
  {
#define ERROR 0.001
  double d;
  d = exp - actual;
  d = d < 0.0 ? -d : d;
  if ((d < -ERROR) || (d > ERROR)) {
    char expStr[32], actualStr[32];
    (void) sprintf(expStr, "%g", exp);
    (void) sprintf(actualStr, "%g", actual);
    CmpError(expStr, actualStr);
    }
  }
      
static void TraceWrapName()
  {
  printf("Executing %s ...\n", wrapName);
  fflush(stdout);
  }

static void AppTextProc(ctxt, buf, count)
  DPSContext ctxt;
  char *buf;
  unsigned int count;
{
    (void) fflush(stdout);
    (void) fwrite(buf, sizeof(char), count, textFd);
    (void) fflush(textFd);
}

static void AppErrorProc(ctxt, errorCode, arg1, arg2)
  DPSContext ctxt;
  DPSErrorCode errorCode;
  long unsigned int arg1, arg2;
  {
  saveExceptionArg1 = arg1;
  saveExceptionArg2 = arg2;
  if (errorCode != dps_err_ps)
    /* Allow any established error handler to see this rather
       than letting the DPSDefault handler have it - the default
       handler won't RAISE non-ps errors */
    RAISE(errorCode, (char *) ctxt);
  else {
    /* Pass this on to the default handler - it will print its
       message and RAISE the error so our outermost handler
       has a chance to Reset the context */
    Error("");
    DPSDefaultErrorProc(ctxt, errorCode, arg1, arg2);
    }
  }

DPSContext CreateContext()
  {
  DPSContext context;

  context = XDPSCreateSimpleContext(dpy, None, None, 0, 0,
    AppTextProc, AppErrorProc, NULL);

  if (context == NULL) {
    fprintf(stderr, "Unable to create context\n");
    CleanUpAndExit(SYS_ERROR);
    }
  return(context);
  }

/* Wrap called after forcing a deliberate error - cleans up
   the operand and dict stacks. */

defineps PSWCleanup()
  clear cleardictstack
endps

/*==================================================================
 TEST: Booleans
 DESCRIPTION:
   Tests the ability to pass both boolean values to a wrap and
   have the same values returned, and to receive expected boolean
   results from a wrap that evaluates a specified boolean expression.
 TESTS:
   BASIC OPERATION:
	Case 1: --- End-to-end tests ---
		True and false boolean values are passed to a wrap
		which echos those values as results.
	Case 2: --- Return result of boolean expression ---
		A wrap which tests the equality of two integer
		arguments and returns the result is called with
		pairs of integers that will result in true and
		false values being returned.
	Case 3:	--- Return value is overwritten ---
		A 'true' value is passed to a wrap which first
		returns 'false' then 'true'. The 'true' value is 
		verified as the correct return value.
 NOT TESTED:
	None.
 END TEST DESCRIPTION
===================================================================*/

#define CompareBoolean(exp, actual)\
  if (exp != actual) {\
    char *expStr, *actualStr;\
    expStr = exp ? "true" : "false";\
    actualStr = actual ? "true" : "false";\
    CmpError(expStr, actualStr);\
    }

defineps PSWBooleanRoundTrip(boolean in | boolean *result)
  in result
endps

defineps PSWBooleanExpression(int a, b | boolean *result)
  a b eq result
endps

defineps PSWBooleanOverwrite(boolean in | boolean *result)
  in false result result
endps

void Booleans()
  {
  int /* boolean */	in, out;

  /* Case 1 */

  DoWrap(PSWBooleanRoundTrip, (True, &out));
  CompareBoolean(True, out);
  DoWrap(PSWBooleanRoundTrip, (False, &out));
  CompareBoolean(False, out);

  /* Case 2 */

  DoWrap(PSWBooleanExpression, (1, 1, &out));
  CompareBoolean(True, out);
  DoWrap(PSWBooleanExpression, (1, 2, &out));
  CompareBoolean(False, out);

  /* Case 3 */

  DoWrap(PSWBooleanOverwrite, (True, &out));
  CompareBoolean(True, out);

  }


/*==================================================================
 TEST: User objects
 DESCRIPTION:
   Tests ability to pass user object IDs and have them correctly
   evaluated. No 'return value' tests are performed: userobject
   is not a valid type for returned values.
 TESTS:
   BASIC OPERATION:
	Case 1: --- Test correct evaluation of userobject ID ---
		A wrap that associates a given ID with the
		integer value '10' is called. The ID is then passed
		to a wrap which evaluates the ID and should return
		the integer value '10'.
	Case 2: --- Test correct evaluation of userobject ID ---
		A wrap that associates a given ID with an executable
		array (procedure) is called. The ID is then passed
		to a wrap which evaluates the ID and should execute
		the procedure. The procedure negates the top element
		on the stack (which is a copy of an integer value
		passed to the wrap). The top value is then returned
		as the wrap result. We expect this result to be 
		the negative of the wrap's input value.
 NOT TESTED:
	None.
 END TEST DESCRIPTION
===================================================================*/

defineps PSWUserobjectDefineInt(long int id)
  id 10 defineuserobject
endps

defineps PSWUserobjectEvalInt(userobject id | int *result)
  id result
endps

defineps PSWUserobjectDefineProc(long int id)
  id {neg} defineuserobject
endps

defineps PSWUserobjectEvalProc(userobject id; int val | int *result)
  val id result
endps

void UserObjects()
  {
  Userobject	objID;
  int		result;

  /* Case 1 */

  objID = 1;
  DoWrap(PSWUserobjectDefineInt, (objID));
  DoWrap(PSWUserobjectEvalInt, (objID, &result));
  Compare(10, result, "%d");

  /* Case 2 */

  objID = 2;
  DoWrap(PSWUserobjectDefineProc, (objID));
  DoWrap(PSWUserobjectEvalProc, (objID, 25, &result));
  Compare(-25, result, "%d");

  }

/*==================================================================
 TEST: Integers
 DESCRIPTION:
   Tests verify the proper output and input of all integer types,
   both signed and unsigned. Truncation of long values when
   returned to variables of shorter types is checked. Returning
   integer values into float and double variables is also checked.
 TESTS:
   BASIC OPERATION:
	Case 1: --- Basic round-trip tests ---
		Signed short, int, and long values are
		passed to a wrap and returned to variables of
		the same type. The values of passed and returned
		variables are checked for equality. This test is
		performed for values at each end of the range
		for each type.
	Case 2: --- Use unsigned types ---
		Unsigned short, int, and long values are
		passed and returned as the corresponding signed
		types. This tests whether the wrap body is properly
		casting unsigned input arguments to signed integers.
	Case 3: --- Return truncated value ---
		The wrap returns a value that exceeds the max
		value for a short int. Correct truncation
		of the returned value is verified; the short 
		variable is declared in the middle of an
		array of elements with known values. Array elements
		'on either side' of the returned value are checked
		to verify their contents have not been smashed.
	Case 4:	--- Pass integer, return float, double ---
		Max and min long int values are passed to a wrap
		that returns a float value to verify correct
		conversion of integer to real on returned values.
		The same test is repeated with a wrap that returns
		double values instead of floats.
	Case 5:	--- Return value is overwritten ---
		A known value is passed to a wrap which first
		returns the negative of the input parameter,
		then returns the original value of the input
		parameter. The original value is verified as
		the correct return value.
 NOT TESTED:
	None.
 END TEST DESCRIPTION
===================================================================*/

defineps PSWShortIntRoundTrip(short in | short *out)
  in out
endps

defineps PSWIntRoundTrip(int in | int *out)
  in out
endps

defineps PSWLongIntRoundTrip(long in | long *out)
  in out
endps

defineps PSWUshortIntRoundTrip(unsigned short in | short *out)
  in out
endps

defineps PSWUintRoundTrip(unsigned int in | int *out)
  in out
endps

defineps PSWUlongIntRoundTrip(unsigned long in | long *out)
  in out
endps

defineps PSWTruncateToShort(int in | short *out)
  in out
endps

defineps PSWLongToFloat(long in | float *out)
  in out
endps

defineps PSWLongToDouble(long in | double *out)
  in out
endps

defineps PSWIntOverwrite(int in | int *out)
  in dup neg out out
endps

long GenMax(typeSize)
  int	typeSize;
  {
  int	bits = typeSize * 8 - 1;
  long	val = 0;

  for (; bits > 0; bits--)
    val = (val << 1) + 1;
  return(val);
  }

void Integers()
  {
  short s, sR; int i, iR; long l, lR; 
  short a[3];
  unsigned short us, maxUshort; unsigned int ui, maxUint; 
  unsigned long ul, maxUlong;
  long maxShort, minShort, maxInt, minInt, maxLong, minLong;
  float f; double d;

  maxShort = GenMax(sizeof(short)); minShort = -maxShort - 1;
  maxUshort = ((unsigned short) maxShort << 1) + 1;
  maxInt = GenMax(sizeof(int)); minInt = -maxInt - 1;
  maxUint = ((unsigned int) maxInt << 1) + 1;
  maxLong = GenMax(sizeof(long)); minLong = -maxLong - 1;
  maxUlong = ((unsigned long) maxLong << 1) + 1;

  /* Case 1 */

  s = minShort;
  DoWrap(PSWShortIntRoundTrip, (s, &sR));
  Compare(s, sR, "%d");
  s = maxShort;
  DoWrap(PSWShortIntRoundTrip, (s, &sR));
  Compare(s, sR, "%d");

  i = minInt;
  DoWrap(PSWIntRoundTrip, (i, &iR));
  Compare(i, iR, "%d");
  i = maxInt;
  DoWrap(PSWIntRoundTrip, (i, &iR));
  Compare(i, iR, "%d");

  l = minLong;
  DoWrap(PSWLongIntRoundTrip, (l, &lR));
  Compare(l, lR, "%ld");
  l = maxLong;
  DoWrap(PSWLongIntRoundTrip, (l, &lR));
  Compare(l, lR, "%ld");

  /* Case 2 */

  us = maxUshort;
  DoWrap(PSWUshortIntRoundTrip, (us, &sR));
  Compare((short) us, sR, "%d");

  ui = maxUint;
  DoWrap(PSWUintRoundTrip, (ui, &iR));
  Compare((int) ui, iR, "%d");

  ul = maxUlong;
  DoWrap(PSWUlongIntRoundTrip, (ul, &lR));
  Compare((long) ul, lR, "%ld");

  /* Case 3 */

  a[0] = -1; a[1] = -2; a[2] = -3;
  DoWrap(PSWTruncateToShort, (maxUshort + 2, &a[1]));
  Compare(1, a[1], "%d");
  Compare(-1, a[0], "%d");
  Compare(-3, a[2], "%d");

  /* Case 4 */

  DoWrap(PSWLongToFloat, (maxLong, &f));
  CompareReal((float) maxLong, f);
  DoWrap(PSWLongToFloat, (minLong, &f));
  CompareReal((float) minLong, f);

  DoWrap(PSWLongToDouble, (maxLong, &d));
  CompareDouble((double) maxLong, d);
  DoWrap(PSWLongToDouble, (minLong, &d));
  CompareDouble((double) minLong, d);

  /* Case 5 */

  DoWrap(PSWIntOverwrite, (maxInt, &i));
  Compare(maxInt, i, "%d");

  }


/*==================================================================
 TEST: Real number output & input
 DESCRIPTION:
   Variables of type float and double are passed to wraps which
   return the same values to test the conversion of C 'real' types
   to PS reals and back again. Typecheck errors are tested by
   trying to return a real number when the result is defined
   as int. The results of passing double values that exceed the 
   PS max real number range tested.
 TESTS:
   BASIC OPERATION:
	Case 1: --- Basic round-trip tests ---
		Max and min float values are passed to a wrap
		that echos the same values back. Double values
		in the range of max/min float values are passed
		to a wrap that echos the same values back.
		The same tests are repeated for float values
		closest to 0 (both positive and negative).
	Case 2: --- Fractional float -> integer tests ---
		Positive and negative float values with fractional
		parts are passed to a wrap which returns integer
		values. This should generate a typecheck error.
	Case 3:	--- Large double value truncation tests ---
		Double values exceeding -1E38 and 1E38 are passed
		to a wrap which returns float values. The returned
		results should equal "Infinity".
	Case 4:	--- Return value is overwritten ---
		A known value is passed to a wrap which first
		returns the negative of the input parameter,
		then returns the original value of the input
		parameter. The original value is verified as
		the correct return value.
 NOT TESTED:
	None.
 END TEST DESCRIPTION
===================================================================*/

defineps PSWFloatRoundTrip(float in | float *out)
  in out
endps

defineps PSWDoubleRoundTrip(double in | double *out)
  in out
endps

defineps PSWFloatToInt(float in | int *out)
  in out
endps

defineps PSWDoubleToFloat(double in | float *out)
  in out
endps

defineps PSWFloatOverwrite(float in | float *out)
  in dup neg out out
endps

defineps PSWDoubleOverwrite(double in | double *out)
  in dup neg out out
endps

void Reals()
  {
  float f, fR, maxFloat, minFloat, smallestFraction, smallestNegFraction;
  double d, dR, largeDouble, smallDouble;
  Bool gotException;
  int	i;

  maxFloat = 1E38; minFloat = -1E38;
  smallestFraction = 1e-38; smallestNegFraction = -1E-38;
  largeDouble = maxFloat * 10; smallDouble = minFloat * 10;

  /* Case 1 */

  f = minFloat;
  DoWrap(PSWFloatRoundTrip, (f, &fR));
  CompareReal(f, fR);
  f = maxFloat;
  DoWrap(PSWFloatRoundTrip, (f, &fR));
  CompareReal(f, fR);

  d = minFloat;
  DoWrap(PSWDoubleRoundTrip, (d, &dR));
  CompareDouble(d, dR);
  d = maxFloat;
  DoWrap(PSWDoubleRoundTrip, (d, &dR));
  CompareDouble(d, dR);

  f = smallestFraction;
  DoWrap(PSWFloatRoundTrip, (f, &fR));
  CompareReal(f, fR);
  f = smallestNegFraction;
  DoWrap(PSWFloatRoundTrip, (f, &fR));
  CompareReal(f, fR);

  d = smallestFraction;
  DoWrap(PSWDoubleRoundTrip, (d, &dR));
  CompareDouble(d, dR);
  d = smallestNegFraction;
  DoWrap(PSWDoubleRoundTrip, (d, &dR));
  CompareDouble(d, dR);

  /* Case 2 */

  gotException = False;
  DURING
    DoWrap(PSWFloatToInt, (maxFloat, &i));
  HANDLER
    if (Exception.Code != dps_err_resultTypeCheck)
      RERAISE;
    gotException = True;
  END_HANDLER

  if (!gotException)
    Error("expected typecheck error - none occurred");

  /* Case 3 */

  DoWrap(PSWDoubleToFloat, (largeDouble, &f));
  Compare((float) largeDouble, f, "%g");

  DoWrap(PSWDoubleToFloat, (smallDouble, &f));
  Compare((float) smallDouble, f, "%g");

  /* Case 4 */

  DoWrap(PSWFloatOverwrite, (maxFloat, &f));
  CompareReal(maxFloat, f);

  DoWrap(PSWDoubleOverwrite, (maxFloat, &d));
  CompareDouble(maxFloat, d);

  }


/*==================================================================
 TEST: Character strings
 DESCRIPTION:
   Tests correct operation of wraps accepting character strings
   and arrays as input parameters and returning character strings
   and arrays as output parameters. Types of tests include: basic 
   'echo' testing (treating the input parameters as PS string
   objects), treating char strings as PS names (both literal and
   executable), returning a series of array elements, and arrays
   declared with both static and dynamic bounds.
 TESTS:
   BASIC OPERATION:
	Case 1: --- Basic round-trip tests ---
		Character strings (up to the maximum PS string
		limit) are passed to a wrap which (treating the
		parameter as a string object) returns the string
		as its result. The same test is performed using
		character arrays of statically and dynamically
		declared length.
	Case 2: --- String as name tests ---
		A string is is passed to a wrap which "defs" the 
		string as the name of an integer object with value as 
		specified as a parameter to the wrap. This name is
		then looked up as a literal name via "known";
		if found, the name is executed. This produces its
		value which is then returned as the wrap result.
		If not found, the original input value is negated
		and returned.
		Also, try passing a string longer than the max
		name to the same wrap. A "dps_err_nameTooLong"
		error should result.
	Case 3:	--- Returning character strings ---
		A wrap that returns a string of the specified
		length is called twice:
		- a 255 byte string is returned. Each byte has
		  a value equal to its index in the string. The
		  string is checked for a null terminator in the
		  proper position.
		- a 0 length string is returned.
		A wrap that returns a series of strings to a single
		return parameter is called to test that only the 
		first string in the series is returned.
	Case 4:	--- Returning character arrays ---
		A wrap that accepts a character array with dynamic
		bounds and a "return chunk" size as input parameters,
		and returns an array with dynamically specified bounds
		is called with different sets of parameters:
		- the input string, return chunk size, and output
		  array bounds make the wrap return an array the
		  same size as the input array - the data is
		  stored in the array in one reference.
		- the input string, return chunk size, and output
		  array bounds make the wrap return an array shorter
		  than the input array. The wrap attempts to store
		  results in the output array in two chunks; the
		  first chunk fits, and all but the last byte of
		  the second chunk fits.
		- the input string, return chunk size, and output
		  array bounds make the wrap return an array shorter
		  than the input array. The wrap attempts to store
		  results in the output array in two chunks; the
		  first chunk fits but only the first byte of the
		  second chunk fits.
		- the input string, return chunk size, and output
		  array bounds make the wrap return an array longer
		  than the input array. The result data is stored
		  in 3 chunks; the returned string is checked to
		  ensure that bytes beyond those explicitly returned
		  by the wrap have not been overwritten.
 NOT TESTED:
	Passing string longer than size allowed by PS.
 END TEST DESCRIPTION
===================================================================*/

defineps PSWCharStringRoundTrip(char *in | char *out)
  (in) out
endps

defineps PSWCharStaticArrayRoundTrip(char in[10] | char out[10])
  (in) out
endps

defineps PSWCharVarArrayRoundTrip(char in[l]; int l | char out[l])
  (in) out
endps

defineps PSWCharStrAsName(char *name; int value | int *result)
  /name value def
  userdict /name known 
    {name}
    {value neg} ifelse
  result
endps

defineps PSWCharReturnStr(int len | char *retStr)
  /str len string def
  1 1 len {dup 1 sub exch str 3 1 roll put} for
  str retStr
endps

defineps PSWCharReturnSeries(int len | char *retStr)
  /str len string def
  1 1 len {dup 1 sub exch str 3 1 roll put} for
  str retStr
  (better not be returned) retStr
  (this either) retStr
endps

defineps PSWCharReturnAry(char *in; int len, chunk | char retStr[len])
  /chunks (in) length chunk idiv def
  /byte 0 def
  chunks {
    (in) byte chunk getinterval retStr
    /byte byte chunk add def
    } repeat
endps

#define CompareStr(exp, actual)\
  if (strcmp(exp, actual)) {\
    CmpError(exp, actual);\
    }

#define CompareStrAry(exp, actual, len)\
  if (strncmp(exp, actual, len)) {\
    CmpError(exp, actual);\
    }

/* Max string that can be passed in a wrap as a char * or
   array with dynamically declared bounds is NOT 65535 bytes
   long. This is due to pswrap building a binary object sequence
   whose length field is only 16 bits long. For our
   purposes, just use a fairly long string. */
#define MAX_PS_STRING 65535
#define LONG_PS_STRING 50000

#define MAX_NAME_LEN 127

void CharacterStrings()
  {
  char	charStr[MAX_PS_STRING+1], rCharStr[MAX_PS_STRING+1];
  int	i, len, chunk;
  Bool gotException = False;

  /* Case 1 */

  for( i = 0; i < LONG_PS_STRING; i++)
    charStr[i] = '0';
  charStr[i] = '\0';
  DoWrap(PSWCharStringRoundTrip, (charStr, rCharStr));
  CompareStr(charStr, rCharStr);

  DoWrap(PSWCharStaticArrayRoundTrip, (charStr, rCharStr));
  CompareStrAry(charStr, rCharStr, 10);

  DoWrap(PSWCharVarArrayRoundTrip, (charStr, LONG_PS_STRING, rCharStr));
  CompareStrAry(charStr, rCharStr, LONG_PS_STRING);

  /* Case 2 */

  (void) strcpy(charStr, "A name");
  DoWrap(PSWCharStrAsName, (charStr, 10, &i));
  Compare(10, i, "%d");

  for( i = 0; i < MAX_NAME_LEN; i++)
    charStr[i] = '0';
  charStr[i] = '\0';
  DoWrap(PSWCharStrAsName, (charStr, 10, &i));
  Compare(10, i, "%d");

#ifdef BUG
  DURING
    for( i = 0; i <= MAX_NAME_LEN; i++)
      charStr[i] = '0';
    charStr[i] = '\0';
    DoWrap(PSWCharStrAsName, (charStr, 10, &i));
  HANDLER
    if (Exception.Code != dps_err_nameTooLong)
      RERAISE;
    gotException = True;
    PSWCleanup();
  END_HANDLER

  if (!gotException)
    Error("expected name too long error - none occurred");
#endif BUG

  /* Case 3 */

  len = 0;
  DoWrap(PSWCharReturnStr, (len, rCharStr));
  charStr[len] = '\0';
  CompareStrAry(charStr, rCharStr, len+1);

  len = 255;
  DoWrap(PSWCharReturnStr, (len, rCharStr));
  for (i = 0; i < len; i++)
    charStr[i] = i + 1;
  charStr[len] = '\0';
  CompareStrAry(charStr, rCharStr, len+1);

  DoWrap(PSWCharReturnSeries, (len, rCharStr));
  CompareStrAry(charStr, rCharStr, len+1);

  /* Case 4 - all variants use the same 10 byte input string
     but vary the "len" of the return string and the "chunk"
     size of substrings of the input string to return. */

  (void) strcpy(charStr, "0123456789");
  len = 10;
  chunk = 10;
  DoWrap(PSWCharReturnAry, (charStr, len, chunk, rCharStr));
  CompareStrAry(charStr, rCharStr, len);

  (void) strcpy(rCharStr, "----------");
  len = 9;
  chunk = 5;
  DoWrap(PSWCharReturnAry, (charStr, len, chunk, rCharStr));
  CompareStr("012345678-", rCharStr);

  (void) strcpy(rCharStr, "----------");
  len = 6;
  chunk = 5;
  DoWrap(PSWCharReturnAry, (charStr, len, chunk, rCharStr));
  CompareStr("012345----", rCharStr);

  (void) strcpy(rCharStr, "----------");
  len = 11;
  chunk = 3;
  DoWrap(PSWCharReturnAry, (charStr, len, chunk, rCharStr));
  CompareStr("012345678-", rCharStr);

  }


/*==================================================================
 TEST: Arrays
 DESCRIPTION:
   Tests correct operation of wraps accepting arrays as input 
   parameters and returning arrays as output parameters. Types 
   of tests include: basic 'echo' testing, accessing individual
   elements of an array, returning a series of array elements, 
   and arrays declared with both static and dynamic bounds.
   
 TESTS:
   BASIC OPERATION:
	Case 1: --- Basic round-trip tests ---
		Integer arrays with bounds up to the maximum PS 
		array limit are passed to a wrap which returns 
		the array as its result. The same test is 
		performed using arrays of statically and dynamically
		declared length.
	Case 2:	--- Accessing individual array elements ---
		A wrap that returns the 0th and 1st elements
		of the specified integer array is called. The
		returned values are checked against the known
		array elements.
	Case 3:	--- Returning array elements one by one ---
		A wrap that accepts an integer array with static
		bounds and an element count, and returns an array 
		with dynamic bounds is defined. Its function is
		to iteratively get an element from the input
		array and store it in the return array (up to the
		specified element count). It is called with
		varying element count and size of output array
		such that:
		- the number of elements exactly fills the output
		  array.
		- the number of elements returned is less that the
		  size of the output array. "Unreturned" elements
		  in the output array are verified to ensure they
		  have not been smashed.
		- the number of elements returned is greater than
		  the size of the output array. Elements of the
		  output array beyond the bounds declared to the
		  wrap are checked to ensure they were not smashed.
	Case 4:	--- Returning a series of array elements ---
		A wrap that accepts an integer array with dynamic
		bounds and a "return chunk" size as input parameters,
		and returns an array with dynamically specified bounds
		is called with 3 different sets of parameters:
		- the input array, return chunk size, and output
		  array bounds make the wrap return an array the
		  same size as the input array - the data is
		  stored in the array in one reference.
		- the input array, return chunk size, and output
		  array bounds make the wrap return an array shorter
		  than the input array. The wrap attempts to store
		  results in the output array in two chunks; the
		  first chunk fits, and all but the last element of
		  the second chunk fits.
		- the input array, return chunk size, and output
		  array bounds make the wrap return an array longer
		  than the input array. The result data is stored
		  in 3 chunks; the returned array is checked to
		  ensure that elements beyond those explicitly returned
		  by the wrap have not been overwritten.
 NOT TESTED:
	Passing array longer than size allowed by PS.
 END TEST DESCRIPTION
===================================================================*/

defineps PSWStaticArrayRoundTrip(int in[10] | int out[10])
  in out
endps

defineps PSWVarArrayRoundTrip(int in[l]; int l | int out[l])
  in out
endps

defineps PSWArrayRet2Elements(int in[10] | int *a, *b)
  \in[0] a \in[1] b
endps

defineps PSWArrayRetElements(int in[20]; int elements, len 
			     | int retAry[len])
  0 1 elements 1 sub {
    in exch get retAry
    } for
endps

defineps PSWArrayRetSeries(int in[10]; int len, chunk 
			   | int retAry[len])
  /chunks in length chunk idiv def
  /element 0 def
  chunks {
    in element chunk getinterval retAry
    /element element chunk add def
    } repeat
endps

#define CompareArray(exp, actual, len)\
  for (i = 0; i < len; i++) { \
    Compare(exp[i], actual[i], "%d");\
    }

/* Max array that can be passed in a wrap with dynamically 
   declared bounds is NOT 65535 elements
   long. This is due to pswrap building a binary object sequence
   whose length field is only 16 bits long. For our
   purposes, just use a fairly long array. */
#define MAX_PS_ARRAY 65535
#define LONG_PS_ARRAY 5000

static void ZeroArray(a, len)
  int	a[];
  int	len;
  {
  int	i;

  for (i = 0; i < len; i++)
    a[i] = 0;
  }

static void SetExpArray(a, fill, zero)
  int	a[];
  int	fill, zero;
  {
  int	i;

  for (i = 0; i < zero; i++)
    if (i < fill)
      a[i] = i;
    else
      a[i] = 0;
  }

void Arrays()
  {
  static int	array[MAX_PS_ARRAY+1], rArray[MAX_PS_ARRAY+1];
  int	expArray[20];
  int	i, len, elements, chunk;

  for (i = 0; i < LONG_PS_ARRAY; i++)
    array[i] = i;

  /* Case 1 */

  DoWrap(PSWStaticArrayRoundTrip, (array, rArray));
  CompareArray(array, rArray, 10);

  DoWrap(PSWVarArrayRoundTrip, (array, LONG_PS_ARRAY, rArray));
  CompareArray(array, rArray, LONG_PS_ARRAY);

  /* Case 2 */

  DoWrap(PSWArrayRet2Elements, (array, &i, &len));
  Compare(array[0], i, "%d");
  Compare(array[1], len, "%d");

  /* Case 3 */

  elements = len = 10;
  DoWrap(PSWArrayRetElements, (array, elements, len, rArray));
  CompareArray(array, rArray, elements);

  elements = 9;
  len = 10;
  rArray[elements] = 0;
  DoWrap(PSWArrayRetElements, (array, elements, len, rArray));
  CompareArray(array, rArray, elements);
  Compare(0, rArray[elements], "%d");

  elements = 11;
  len = 10;
  rArray[len] = 0;
  DoWrap(PSWArrayRetElements, (array, elements, len, rArray));
  CompareArray(array, rArray, len);
  Compare(0, rArray[len], "%d");

  /* Case 4 - all variants use the same 10 element input array
     but vary the "len" of the return array and the "chunk"
     size of subarrays of the input array to return. */

  len = 10;
  chunk = 10;
  DoWrap(PSWArrayRetSeries, (array, len, chunk, rArray));
  CompareArray(array, rArray, len);

  len = 9;
  chunk = 5;
  ZeroArray(rArray, 10); SetExpArray(expArray, len, 10);
  DoWrap(PSWArrayRetSeries, (array, len, chunk, rArray));
  CompareArray(expArray, rArray, 10);
  
  len = 6;
  chunk = 5;
  ZeroArray(rArray, 10); SetExpArray(expArray, len, 10);
  DoWrap(PSWArrayRetSeries, (array, len, chunk, rArray));
  CompareArray(expArray, rArray, 10);

  len = 11;
  chunk = 3;
  ZeroArray(rArray, 11); SetExpArray(expArray, 9, 11);
  DoWrap(PSWArrayRetSeries, (array, len, chunk, rArray));
  CompareArray(expArray, rArray, len);

  }


/*==================================================================
 TEST: Context IDs
 DESCRIPTION:
   Tests that invoking a wrap whose first input parameter is
   declared as type DPScontext directs execution of the wrap 
   to the specified context.
 TESTS:
   BASIC OPERATION:
	Case 1: --- Execution of same wraps by different contexts ---
		Two contexts are created. The first one then
		executes a wrap that changes its gray level to .5
		and the second sets its level to .75. Each context
		is then directed to execute a wrap to return its
		gray level. The returned gray levels are compared
		to expected levels; if they match, it is apparent
		that the DPSContext parameters in the 2 wraps
		had the desired effect.
 NOT TESTED:
	None.
 END TEST DESCRIPTION
===================================================================*/

defineps PSWSetGray(DPSContext c; float gray)
  gray setgray
endps

defineps PSWGetGray(DPSContext c | float *gray)
  currentgray gray 
endps

void ContextIDs()
  {
  DPSContext	ctxt1, ctxt2;
  float		g, c1g, c2g;

  ctxt1 = CreateContext();
  ctxt2 = CreateContext();

  c1g = 0.5; c2g = 0.75;
  DoWrap(PSWSetGray, (ctxt1, c1g));
  DoWrap(PSWSetGray, (ctxt2, c2g));

  DoWrap(PSWGetGray, (ctxt1, &g));
  Compare(c1g, g, "%f");

  DoWrap(PSWGetGray, (ctxt2, &g));
  Compare(c2g, g, "%f");

  }

/*==================================================================
 TEST: Returning mixed types
 DESCRIPTION:
   Tests wraps that return different types of parameters.
 TESTS:
   BASIC OPERATION:
	Case 1: --- Echo all types ---
		A wrap that accepts input parameters of all valid 
		"return parameter types" and returns those
		input parameters without modification is called.
		The return parameters are verified for correct
		contents.
 NOT TESTED:
	None.
 END TEST DESCRIPTION
===================================================================*/

defineps PSWEchoAll(short s; int i; long l;
		    unsigned short us; unsigned ui; unsigned long ul;
		    float f; double d;
		    boolean b;
		    char *str; char chrStAry[13]; char chrVarAry[i];
		    float stAry[20]; double varAry[i];
		    |
                    short *sR; int *iR; long *lR;
		    unsigned short *usR; unsigned *uiR; unsigned long *ulR;
		    float *fR; double *dR;
		    boolean *bR;
		    char *strR; char chrStAryR[13]; char chrVarAryR[i];
		    float stAryR[20]; double varAryR[i];
		    )
  s sR i iR l lR us usR ui uiR ul ulR
  f fR d dR
  b bR
  (str) strR (chrStAry) chrStAryR (chrVarAry) chrVarAryR
  stAry stAryR varAry varAryR
endps

void CompareRealArray(exp, actual, len)
  float	exp[], actual[];
  int	len;
  {
  int i;
  for (i = 0; i < len; i++) 
    CompareReal(exp[i], actual[i]);
  }

void CompareDoubleArray(exp, actual, len)
  double	exp[], actual[];
  int		len;
  {
#define ERROR 0.001
  int i;
  double d;
  for (i = 0; i < len; i++) { 
    d = exp[i] - actual[i];
    d = d < 0.0 ? -d : d;
    if ((d < -ERROR) || (d > ERROR)) {
      char expStr[32], actualStr[32];
      (void) sprintf(expStr, "%g", exp[i]);
      (void) sprintf(actualStr, "%g", actual[i]);
      CmpError(expStr, actualStr);
      }
    }
  }
      

void ReturnMixed()
  {
  int j;
  short s = 32767; int i = 10; long l = GenMax(sizeof(long));
  short sR; int iR; long lR;
  unsigned short us = 65535; unsigned ui = 20; unsigned long ul = 1 << 31;
  unsigned short usR; unsigned uiR; unsigned long ulR;
  float f = 6.02e23; double d = -f;
  float fR; double dR;
  int /* boolean */ b = True;
  int /* boolean */ bR;
  char *str; char chrStAry[13]; char chrVarAry[10];
  char strR[20]; char chrStAryR[20]; char chrVarAryR[20];
  float stAry[20]; double varAry[10];
  float stAryR[20]; double varAryR[10];

  str = "character string";
  (void) strcpy(chrStAry, "13 characters");
  (void) strcpy(chrVarAry, "0123456789");

  for (j = 0; j < 20; j++)
    stAry[j] = j * 3.1415;

  for (j = 0; j < 10; j++)
    varAry[j] = j * 6.02;

  wrapName = "PSWEchoAll";
  if (optionTrace) TraceWrapName();
  PSWEchoAll(s, i, l, us, ui, ul, f, d, b, 
	 str, chrStAry, chrVarAry, stAry, varAry,
         &sR, &iR, &lR, &usR, &uiR, &ulR, &fR, &dR, &bR,
	 strR, chrStAryR, chrVarAryR, stAryR, varAryR);

  Compare(s, sR, "%d");
  Compare(i, iR, "%d");
  Compare(l, lR, "%ld");
  Compare(us, usR, "%d");
  Compare(ui, uiR, "%d");
  Compare(ul, ulR, "%ld");
  CompareReal(f, fR);
  CompareReal(d, dR);
  CompareStr(str, strR);
  CompareStrAry(chrStAry, chrStAryR, 13);
  CompareStrAry(chrVarAry, chrVarAryR, 10);
  CompareRealArray(stAry, stAryR, 20);
  CompareDoubleArray(varAry, varAryR, 10);

  }

void RunTest(tstProc)
  void	(*tstProc)();
  {
  testName = "";
  DURING
    (*tstProc)();
  HANDLER
    /* This is the outermost exception handler */
    errCount++;
    if (Exception.Code == dps_err_ps)
      DPSResetContext((DPSContext)Exception.Message);
    else {
      /* If not a ps error, Default handler never got a look
	 at it (see the AppErrorProc to understand why). Call
	 the default handler now, passing the args saved by
	 AppErrorProc. */
      Error("");
      DPSDefaultErrorProc((DPSContext) Exception.Message, 
	Exception.Code, saveExceptionArg1, saveExceptionArg2);
      }
  END_HANDLER
  }

/* Array of pointers to test procedures */

void	(*testProcs[])() = {
  Booleans
 ,UserObjects
 ,Integers
 ,Reals
 ,CharacterStrings
 ,Arrays
 ,ContextIDs
 ,ReturnMixed
 ,NULL
 };

main(argc, argv)
  int argc;
  char **argv;
  {
  int		i;
  char 		st[LINEBUF];

  GetCommandLineOptions(&argc, &argv);
    
    dpy = XOpenDisplay(NULL);
    if (dpy == NULL) {
      fprintf(stderr, "Unable to open display\n");
      CleanUpAndExit(SYS_ERROR);
      }

  /* Create context */

  context = CreateContext();
        
  DPSSetTextBackstop(AppTextProc);
  DPSSetContext(context);
  DPSPrintf(context, "resyncstart\n");
  if (doAscii) {
    fdcontext = DPSCreateTextContext(AppTextProc, AppErrorProc);
    DPSChainContext(context,fdcontext);
    }

  if (! doAscii) printf("Begin test ...\n");
    
  /* Execute each test within an exception handler to allow
     the entire suite to execute past errors in individual tests */

  for (i = 0; testProcs[i] != NULL; i++)
    RunTest(testProcs[i]);

  /* Disconnect from DPS server */
    
  fprintf(stderr,"End test ...\n");
	
  CleanUpAndExit(0);
  }
