
# line 3 "yaccpar"
/* ********************************************************************** *\
 *         Copyright IBM Corporation 1991 - All Rights Reserved           *
 *        For full copyright information see:'andrew/config/COPYRITE'     *
\* ********************************************************************** */
/* $Header: /afs/andrew.cmu.edu/itc/sm/releases/X.V11R5/ftp/src/atk/ness/tokens/RCS/yaccpar,v 1.2 1991/09/13 15:56:51 bobg Exp $ */
/* $ACIS:$ */
/* $Source: /afs/andrew.cmu.edu/itc/sm/releases/X.V11R5/ftp/src/atk/ness/tokens/RCS/yaccpar,v $ */

#if !defined(lint) && !defined(LOCORE) && defined(RCS_HDRS)
char *yaccpar_rcsid = "$Header: /afs/andrew.cmu.edu/itc/sm/releases/X.V11R5/ftp/src/atk/ness/tokens/RCS/yaccpar,v 1.2 1991/09/13 15:56:51 bobg Exp $";
#endif

/*

	Ness version of yaccpar 

	Parser utilizing the tables generated by yacc

adapted by revision from code with this notice:
 * 5799-WZQ (C) COPYRIGHT = NONE
 * LICENSED MATERIALS - PROPERTY OF IBM
 *
 * Source: /ibm/acis/usr/src/usr.bin/yacc/RCS/yaccpar,v 

however, the original code is a lot like the yaccpar on most systems,
so it is more likely owned by AT&T, if anybody

For that matter, this version is substantially revised from any other, 
including the addition of an exception table index, the elimination of goto's,
	and the fact that no variables are global.
*/

/* semantics routines can reset parser state with these macros */
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)
# define yyclearin yychar = -1  /* force read next token */
# define yyerrok yyerrflag = 0	/* force finish error scan mode */

/* constants used in the syntax tables to flag errors */
# define YYERRCODE 256
# define YYFLAG -1000

# ifndef YYMAXDEPTH
# define YYMAXDEPTH 200
# endif

# ifdef YYDEBUG
int yydebug = 0; /* 1 for debugging */
# endif

yyparse() 
{
	YYSTYPE yylval;		/* side return from yylex
			(with lex.h, yylex() is redefined to pass &yylval to lex.c) */
	short yys[YYMAXDEPTH];	/* state stack */
	YYSTYPE yyv[YYMAXDEPTH]; /* store value for each stacked state */

	int yychar = -1; 	/* current input token number */
	int yynerrs = 0; 	/* number of errors */
	short yyerrflag = 0;  	/* error recovery: assume recovered when this is 
		decremented back to zero once for each successfully accepted token */

	register YYSTYPE *yypvt;	/* pt to value stack for semantics routines */
	register short yystate;	/* current state */
	YYSTYPE yyval;		/* current token value */
	register short *yyps;		/* pt to state stack */
	register short yyn;		/* temporary */
	register YYSTYPE *yypv;	/* pt to value stack */
	register short *yyxi;		/* temporary */
	short yyj, yym;		/* temporaries */
	static short **yyxx = NULL;	/* exception table index */

	yystate = 0;	/* bottom state */
	/* yyval = not initialized */
	yynerrs = 0;
	yyps= yys-1;	/* &yys[-1] */
	yypv= yyv-1;	/* &yyv[-1] */

	if (yyxx == NULL) {
		/* build exception table index */
		yyn = 0;	/* find maximum state number */
		for ( yyxi = yyexca; yyxi < yyexca + sizeof(yyexca)/sizeof(short);
				yyxi+=2 )
			if ( *yyxi == -1 && yyxi[1] > yyn )
				yyn = yyxi[1];
		yyxx = (short **)malloc((yyn+1)*sizeof(short *)); /* allocate table */
		for ( yyxi = yyexca; yyxi < yyexca + sizeof(yyexca)/sizeof(short);
				yyxi+=2 )
			if ( *yyxi == -1 )
				yyxx[yyxi[1]] = yyxi+2;  /* point to 1st entry */
	}

while (1) {

	/* in each cycle around this main loop we push a state, and then
	 generate the next state by shift, reduce, or error processing */

	/* put a state and value onto the stack */

		/* ( the following statement had an error:  > instead of >=
			this would have allowed use of the illegal element
			yys[YYMAXDEPTH] ) */
	if( ++yyps >= &yys[YYMAXDEPTH] ) { 
		yyerror( "yacc stack overflow" ); 
		return(1);
	}
	*yyps = yystate;
	*++yypv = yyval;

	/* process the new state */
	yyn = yypact[yystate];

	if( yyn > YYFLAG ) {
		/* check for shift */

		/* read next token */
		if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
		yyn += yychar;
		if( yyn >= 0 && yyn < YYLAST 
				&& yychk[ yyn = yyact[ yyn ] ] == yychar ) { 
			/* valid shift */

#			ifdef YYDEBUG
			if( yydebug ) printf( " char 0%o causes shift to state %d\n",
					yychar, yyn );
#			endif

			yychar = -1;	/* absorb current token */
			yyval = yylval;
			yystate = yyn;
			if( yyerrflag > 0 ) --yyerrflag;
			continue;	/* go stack the new state */
		}
	}

	/* not a shift operation: take default state action */
	yyn = yydef[yystate];
	if( yyn == -2 ) {
		/* be sure we have a token to look at */
		if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;

		/* look through exception table */
		for ( yyxi = yyxx[yystate];  *yyxi >= 0; yyxi += 2 )
			if( *yyxi == yychar ) break;
		yyn = yyxi[1];
		if( yyn < 0 ) return(0);   /* accept */
	}

	if( yyn == 0 ) {
		/* error ... attempt to resume parsing */

		switch( yyerrflag ) {

		case 0:   /* brand new error */

			yyerror( "syntax error" );
	yyerrlab:
			++yynerrs;
			/* DROP THROUGH */

		case 1:
		case 2: /* incompletely recovered error ... try again */

			yyerrflag = 3;  /* must accept 3 tokens
				before restarting scan */

			/* find a state where "error" is a legal shift action */

			while ( TRUE ) {
			   if ( yyps < yys )	/* reached stack bottom */
				return (1);	/* abort */
			   yyn = yypact[*yyps] + YYERRCODE;
			   if( yyn >= 0 && yyn < YYLAST 
					&& yychk[yyact[yyn]] == YYERRCODE )
				break; /* found a state where "error" is valid */
#			   ifdef YYDEBUG
			   if( yydebug ) printf( "error recovery pops state %d, uncovers %d\n", 
				*yyps, yyps[-1] );
#			   endif

			   --yyps;  /* pop stack */
			   --yypv;
			}
			yystate = yyact[yyn];  /* simulate a shift of "error" */
			continue;	/* go stack the error state */

		case 3:  /* no shift yet; clobber input char */

#			ifdef YYDEBUG
			if( yydebug ) printf( "error recovery discards char %d\n", yychar );
#			endif

			if( yychar == 0 ) 
				return(1); /* don't discard EOF, abort */
			yychar = -1;
			/* try again in the same state */
			yystate = *yyps--;
			yyval = *yypv--;
			continue;	/* go push the state we just popped */
		} /* end switch ( yyerrflag ) */
	} /* end if ( yyn == 0 ) */

	/* reduction by production yyn */

	yym = yyn;	/* save yyn for the case operand below */

	/* pop off the states and values for righthand side of rule */
	yyj = yyr2[yyn];
	yyps -= yyj;
	yypvt = yypv;   /* for semantics: point to values for right-hand-side */
	yypv -= yyj;
	yyval = yypv[1];	/* default value is first non-terminal on the right */

	/* consult goto table to find next state */
	yyn = yyr1[yyn];
	yyj = yypgo[yyn] + *yyps + 1;
	if( yyj >= YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) 
		yystate = yyact[yypgo[yyn]];
	/* yystate is set here. yyval will be set in semantics routines */

#	ifdef YYDEBUG
	if( yydebug ) printf("reduce by production %d   new state is %d\n",yym, yystate);
#	endif

	switch ( yym ) {

/* semantics rules follow */
			$@
# line 226 "yaccpar"
/* semantics rules precede */

	} /* end of switch( yym ) */

} /* end while(1) main loop */

}  /* end of Ness version of yaccpar */
